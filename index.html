<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tap-to-Advance AR Experience</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    
    <style>
        /* --- CSS STYLING --- */
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Helvetica', 'Arial', sans-serif; 
            overflow: hidden; 
        }
        
        /* The AR Window */
        model-viewer {
            width: 100vw;
            height: 100vh;
            background-color: #f5f5f5; /* Fallback color */
            --poster-color: #f5f5f5;
        }

        /* The UI Overlay Container */
        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Let taps pass through to the 3D model */
            z-index: 100;
        }

        /* The Branding / Instruction Card */
        .card {
            display: inline-block;
            background: white;
            padding: 16px 24px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            pointer-events: auto; /* Enable clicks on the card */
            cursor: pointer; /* Show it's clickable */
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.2);
        }

        .card:active {
            transform: translateY(0);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .card h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card p {
            margin: 4px 0 0 0;
            font-size: 14px;
            color: #555;
        }

        /* Hide UI while loading */
        model-viewer:not([loaded]) #ui-layer { 
            opacity: 0; 
        }

        /* Custom AR Button Styling */
        #ar-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 200;
            cursor: pointer;
            transition: background 0.2s;
        }

        #ar-button:hover {
            background: #0056CC;
        }

        /* AR Recipe Link - Bottom Overlay */
        /* OLD - REPLACED WITH ar-recipe-card */
        #ar-recipe-link-old {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007AFF;
            color: white !important;
            border: none;
            padding: 16px 32px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.4);
            z-index: 99999 !important; /* Very high z-index to ensure it's above AR camera feed */
            cursor: pointer;
            transition: all 0.2s;
            display: none; /* Hidden by default, shown only in AR mode */
            pointer-events: auto !important; /* Enable clicks */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            text-decoration: none;
            text-align: center;
            opacity: 1 !important;
            visibility: visible !important;
        }

        #ar-recipe-link-old:hover {
            background: #0056CC;
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 25px rgba(0, 122, 255, 0.5);
        }

        #ar-recipe-link-old:active {
            transform: translateX(-50%) scale(0.95);
        }

        /* Show link when AR is active - CSS-based for immediate visibility */
        /* AR Recipe Card - WebXR DOM Overlay (projects onto camera feed) */
        /* Hide the card by default (so it doesn't show on the 3D viewer) */
        /* AR Recipe Card - Hidden by default */
        #ar-recipe-card {
            display: none;
        }

        /* When WebXR AR session starts (session-started or presenting), show the card */
        /* Note: slot="ar-overlay" elements are moved to a special overlay container by model-viewer */
        model-viewer[ar-status="session-started"] #ar-recipe-card,
        model-viewer[ar-status="presenting"] #ar-recipe-card {
            display: flex !important;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            background: white;
            padding: 16px 20px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom));
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 99999;
            pointer-events: auto;
        }
        
        /* Also target the element directly when AR is active */
        model-viewer[ar-status="session-started"] slot[name="ar-overlay"] #ar-recipe-card,
        model-viewer[ar-status="presenting"] slot[name="ar-overlay"] #ar-recipe-card {
            display: flex !important;
        }

        .ar-recipe-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-width: calc(100% - 120px);
        }

        .ar-recipe-description {
            font-size: 14px;
            color: #333;
            margin: 0;
            line-height: 1.4;
        }

        .ar-recipe-url {
            font-size: 12px;
            color: #666;
            margin: 0;
            text-decoration: none;
        }

        .ar-recipe-button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .ar-recipe-button:hover {
            background: #0056CC;
        }

        .ar-recipe-button:active {
            background: #004499;
        }

    </style>
</head>
<body>

    <model-viewer 
        id="ar-viewer"
        src="assets/Dalgona-OneTake_0001.glb"
        ar
        ar-modes="webxr scene-viewer quick-look"
        link="https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona"
        title="NESCAF√â¬Æ 3in1 Dalgona Recipe"
        camera-controls
        disable-tap
        shadow-intensity="1.2"
        environment-image="assets/bryanston_park_sunrise_1k.hdr" 
        tone-mapping="commerce"
        animation-name="animation_0"
        autoplay="true">
        
        <button slot="ar-button" id="ar-button">
            View in your space
        </button>
        
        <!-- AR Recipe Card - WebXR DOM Overlay (projects onto camera feed) -->
        <div slot="ar-overlay" id="ar-recipe-card">
            <div class="ar-recipe-content">
                <p class="ar-recipe-description">How to make NESCAF√â¬Æ 3in1 in Dalgona Coffee Recipe</p>
                <a href="https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona" 
                   class="ar-recipe-url" 
                   target="_blank" 
                   rel="noopener noreferrer">
                    nescafe.com
                </a>
            </div>
            <a href="https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona" 
               class="ar-recipe-button" 
               target="_blank" 
               rel="noopener noreferrer">
                Visit
            </a>
        </div>
    </model-viewer>

    <div id="ui-layer">
        <div class="card" id="info-card">
            <h2 id="step-title">Welcome</h2>
            <p id="step-desc">Tap the Nescaf√© sachet to start!</p>
        </div>
    </div>


    <script type="module">
        // ============================================
        // ON-SCREEN CONSOLE FOR MOBILE DEBUGGING
        // ============================================
        
        function createOnScreenConsole() {
            const consoleDiv = document.createElement('div');
            consoleDiv.id = 'mobile-console';
            consoleDiv.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 200px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.95);
                color: #0f0;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 8px;
                z-index: 10000;
                display: none;
                border-top: 2px solid #0f0;
                box-shadow: 0 -2px 10px rgba(0, 255, 0, 0.3);
            `;
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úï';
            closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: #f00;
                color: white;
                border: none;
                border-radius: 3px;
                width: 24px;
                height: 24px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                z-index: 10001;
            `;
            closeBtn.onclick = () => {
                consoleDiv.style.display = 'none';
            };
            consoleDiv.appendChild(closeBtn);
            
            // Add clear button
            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 35px;
                background: #333;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 8px;
                cursor: pointer;
                font-size: 10px;
                z-index: 10001;
            `;
            clearBtn.onclick = () => {
                const logs = consoleDiv.querySelectorAll('div:not(button)');
                logs.forEach(log => log.remove());
            };
            consoleDiv.appendChild(clearBtn);
            
            document.body.appendChild(consoleDiv);
            
            // Store original console methods
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;
            
            function addToScreen(type, ...args) {
                const consoleDiv = document.getElementById('mobile-console');
                if (!consoleDiv) return;
                
                const message = args.map(arg => {
                    if (arg === null) return 'null';
                    if (arg === undefined) return 'undefined';
                    if (typeof arg === 'object') {
                        try {
                            return JSON.stringify(arg, null, 2);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return String(arg);
                }).join(' ');
                
                const logEntry = document.createElement('div');
                logEntry.style.cssText = `
                    padding: 3px 0;
                    border-bottom: 1px solid #222;
                    word-wrap: break-word;
                    color: ${type === 'error' ? '#ff4444' : type === 'warn' ? '#ffaa00' : type === 'info' ? '#00aaff' : '#00ff00'};
                    white-space: pre-wrap;
                `;
                
                const timestamp = new Date().toLocaleTimeString();
                logEntry.textContent = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
                consoleDiv.appendChild(logEntry);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                
                // Auto-show console for errors and warnings
                if (type === 'error' || type === 'warn') {
                    consoleDiv.style.display = 'block';
                }
            }
            
            // Override console methods
            console.log = function(...args) {
                originalLog.apply(console, args);
                addToScreen('log', ...args);
            };
            
            console.error = function(...args) {
                originalError.apply(console, args);
                addToScreen('error', ...args);
            };
            
            console.warn = function(...args) {
                originalWarn.apply(console, args);
                addToScreen('warn', ...args);
            };
            
            console.info = function(...args) {
                if (originalInfo) originalInfo.apply(console, args);
                addToScreen('info', ...args);
            };
            
            // Toggle console with triple tap
            let tapCount = 0;
            let tapTimer = null;
            document.addEventListener('touchstart', (e) => {
                // Don't trigger on UI elements
                if (e.target.tagName === 'BUTTON' || e.target.closest('#ui-layer')) {
                    return;
                }
                
                tapCount++;
                clearTimeout(tapTimer);
                tapTimer = setTimeout(() => {
                    if (tapCount === 3) {
                        const consoleDiv = document.getElementById('mobile-console');
                        if (consoleDiv) {
                            consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                        }
                    }
                    tapCount = 0;
                }, 400);
            });
            
            // Also allow keyboard toggle (for desktop testing)
            document.addEventListener('keydown', (e) => {
                if (e.key === '`' && e.ctrlKey) {
                    e.preventDefault();
                    const consoleDiv = document.getElementById('mobile-console');
                    if (consoleDiv) {
                        consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                    }
                }
            });
            
            console.log('On-screen console initialized. Triple-tap to toggle, or press Ctrl+`');
        }
        
        // Initialize console immediately
        createOnScreenConsole();
        
        // ============================================
        // CONFIGURATION: Keyframe-based animation with object-specific taps
        // ============================================
        
        const CONFIG = {
            // Path to your 3D model (GLB format) - for 3D viewer mode
            modelPath: 'assets/Dalgona-OneTake_0001.glb',
            
            // Path to compressed model for AR mode (smaller file size for better AR performance)
            arModelPath: 'assets/dalgona-compressed.glb',
            
            // Path to iOS USDZ format (for better iOS Quick Look support)
            // USDZ file provides native animation support in Quick Look
            iosModelPath: 'assets/Dalgona-OneTake_0001.usdz',
            
            // iOS Quick Look Banner Configuration
            // See: https://www.variant3d.com/blog/using-banners-in-quicklooks
            iosBanner: {
                callToAction: 'Visit Recipe',
                checkoutTitle: 'NESCAF√â¬Æ 3in1 Dalgona',
                checkoutSubtitle: 'How to make Dalgona Coffee Recipe',
                canonicalWebPageURL: 'https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona'
            },
            
            // Animation name (single track)
            animationName: 'animation_0',
            
            // Frame rate of your animation
            fps: 30,
            
            // Keyframe spans for each step
            steps: [
                { 
                    startFrame: 1,
                    endFrame: 80,
                    title: 'Step 1: The Mix', 
                    desc: 'Nescaf√© + Water into bowl',
                    objectHint: 'Tap the Nescaf√© sachet, pot, or handle'
                },
                { 
                    startFrame: 80,
                    endFrame: 140,
                    title: 'Step 2: Whip It', 
                    desc: 'Whisking into foam...',
                    objectHint: 'Tap the whisk'
                },
                { 
                    startFrame: 140,
                    endFrame: 200,
                    title: 'Step 3: The Base', 
                    desc: 'Milk into mug...',
                    objectHint: 'Tap the jug'
                },
                { 
                    startFrame: 200,
                    endFrame: 240,
                    title: 'Step 4: Transfer', 
                    desc: 'Bowl into mug...',
                    objectHint: 'Tap the mixing bowl'
                },
                { 
                    startFrame: 240,
                    endFrame: 300,
                    title: 'Step 5: Final Touch', 
                    desc: 'Add ice...',
                    objectHint: 'Tap the scoop or ice bowl',
                    loop: false
                }
            ],
            
            // Object names that trigger each step (will be matched flexibly against GLB node names)
            // Note: Matching is flexible - handles dots/underscores, spaces/underscores, case variations
            interactiveObjects: [
                ['NescafeBTM', 'NescafeTOP_(Copy)', 'NescafeTOP', 'teapot', 'pot', 'handle'],  // Step 1
                ['whisk'],                                                // Step 2
                ['jug'],                                                  // Step 3
                ['mixingbowl', 'mixing.bowl'],                            // Step 4
                ['scoop', 'icebowl', 'ice.bowl']                          // Step 5
            ],
            
            // Welcome message
            welcomeTitle: 'Welcome',
            welcomeDesc: 'Tap here to start!',
            
            // Continue prompt
            continuePrompt: 'Tap the correct object to continue ->',
            
            // Reset message
            resetTitle: 'Replay?',
            resetDesc: 'Tap to start again.',
            
            // Visual feedback for interactive objects
            enableHoverFeedback: true
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        
        const viewer = document.querySelector('#ar-viewer');
        const titleText = document.querySelector('#step-title');
        const descText = document.querySelector('#step-desc');
        const card = document.querySelector('#info-card');

        // Set model paths from config
        viewer.src = CONFIG.modelPath;
        // Set iOS source with Quick Look banner parameters
        if (CONFIG.iosModelPath) {
            // Build iOS URL with banner parameters
            // Parameters are appended with # and separated by &
            // See: https://www.variant3d.com/blog/using-banners-in-quicklooks
            // Note: USDZ URL should be absolute for banner parameters to work
            let iosUrl = CONFIG.iosModelPath;
            
            // Convert relative path to absolute URL if needed
            if (!iosUrl.startsWith('http://') && !iosUrl.startsWith('https://')) {
                // Use current origin to create absolute URL
                const baseUrl = window.location.origin;
                const path = iosUrl.startsWith('/') ? iosUrl : `/${iosUrl}`;
                iosUrl = `${baseUrl}${path}`;
            }
            
            if (CONFIG.iosBanner) {
                const banner = CONFIG.iosBanner;
                const params = [];
                
                // Add banner parameters (URL encoded)
                if (banner.callToAction) {
                    params.push(`callToAction=${encodeURIComponent(banner.callToAction)}`);
                }
                if (banner.checkoutTitle) {
                    params.push(`checkoutTitle=${encodeURIComponent(banner.checkoutTitle)}`);
                }
                if (banner.checkoutSubtitle) {
                    params.push(`checkoutSubtitle=${encodeURIComponent(banner.checkoutSubtitle)}`);
                }
                if (banner.canonicalWebPageURL) {
                    params.push(`canonicalWebPageURL=${encodeURIComponent(banner.canonicalWebPageURL)}`);
                }
                if (banner.price) {
                    params.push(`price=${encodeURIComponent(banner.price)}`);
                }
                
                // Append parameters to USDZ URL with #
                if (params.length > 0) {
                    iosUrl = `${iosUrl}#${params.join('&')}`;
                }
                
                console.log('‚úÖ iOS Quick Look banner configured');
                console.log('Banner parameters:', banner);
            }
            
            viewer.setAttribute('ios-src', iosUrl);
            console.log('‚úÖ USDZ file configured for iOS Quick Look:', CONFIG.iosModelPath);
            console.log('üì± Quick Look will use USDZ file with banner support');
            console.log('iOS URL with banner:', iosUrl);
        } else {
            console.log('‚ö†Ô∏è No USDZ file specified - iOS will use GLB (may have limitations)');
        }
        viewer.animationName = CONFIG.animationName;
        viewer.autoplay = true;  // Temporarily enabled for testing AR mode animations
        viewer.loop = false;

        // Set welcome message
        titleText.innerText = CONFIG.welcomeTitle;
        descText.innerText = CONFIG.welcomeDesc;

        // ============================================
        // MODEL-VIEWER CLICK EVENT SETUP
        // ============================================
        
        // Map of node names to step indices (with flexible matching)
        let nodeToStepMap = new Map();
        let hierarchyNodes = []; // Store hierarchy nodes with meshes
        let THREE = null; // Will store Three.js reference
        let raycaster = null;
        let camera = null;
        
        // Initialize after model loads
        viewer.addEventListener('load', () => {
            // Set initial time to frame 1
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            
            // Access hierarchy and build mappings
            setupHitDetection();
        });
        
        // Also listen for scene-graph-ready event
        viewer.addEventListener('scene-graph-ready', () => {
            console.log('Scene graph ready');
            setupHitDetection();
        });
        
        function setupHitDetection() {
            console.log('Setting up hit detection...', {
                modelLoaded: viewer.loaded,
                hasTHREE: typeof THREE !== 'undefined'
            });
            
            // Wait for model to load
            if (!viewer.loaded) {
                console.log('Model not loaded yet, waiting...');
                viewer.addEventListener('load', () => {
                    console.log('Model loaded, retrying hit detection setup...');
                    setupHitDetection();
                }, { once: true });
                return;
            }
            
            // Import Three.js for raycasting
            if (!window.THREE) {
                console.log('Three.js not found, importing...');
                import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js').then((THREE_Module) => {
                    window.THREE = THREE_Module;
                    THREE = THREE_Module;
                    console.log('Three.js imported successfully');
                    initializeHitDetection();
                }).catch((err) => {
                    console.error('Failed to import Three.js:', err);
                });
            } else {
                THREE = window.THREE;
                console.log('Three.js already available');
                initializeHitDetection();
            }
        }
        
        function initializeHitDetection() {
            if (!THREE) {
                console.error('Three.js not available');
                return;
            }
            
            console.log('Initializing hit detection...');
            
            // Access hierarchy from viewer.model
            const symbols = Object.getOwnPropertySymbols(viewer.model);
            const hierarchySym = symbols.find(s => s.toString().includes('hierarchy'));
            
            if (!hierarchySym) {
                console.error('Could not find hierarchy Symbol');
                console.log('Available symbols:', symbols.map(s => s.toString()));
                return;
            }
            
            const hierarchy = viewer.model[hierarchySym];
            hierarchyNodes = hierarchy.filter(node => node.mesh); // Only nodes with meshes
            
            console.log('Found hierarchy nodes:', hierarchyNodes.length);
            console.log('Node names:', hierarchyNodes.map(n => n.name).filter(Boolean));
            
            // Build flexible node-to-step mapping
            buildFlexibleNodeMapping(hierarchyNodes);
            
            console.log('Node-to-step mapping:', Array.from(nodeToStepMap.entries()));
            
            // Initialize raycasting
            raycaster = new THREE.Raycaster();
            
            // Create camera for raycasting
            // Will be updated on each click to match model-viewer's camera
            camera = new THREE.PerspectiveCamera(
                75,
                viewer.clientWidth / viewer.clientHeight,
                0.1,
                1000
            );
            
            // Store reference to model-viewer's scene for easier access
            // Try to access through renderRoot
            if (viewer.renderRoot) {
                const canvas = viewer.renderRoot.querySelector('canvas');
                if (canvas && canvas.__THREE__) {
                    window.modelViewerScene = canvas.__THREE__.scene;
                    window.modelViewerCamera = canvas.__THREE__.camera;
                    console.log('Found model-viewer scene and camera');
                } else {
                    console.warn('Could not find model-viewer canvas or THREE context');
                }
            }
            
            console.log('‚úÖ Hit detection initialized successfully!');
        }
        
        function buildFlexibleNodeMapping(nodes) {
            // Normalize function to handle variations
            function normalizeName(name) {
                if (!name) return '';
                return name
                    .toLowerCase()
                    .replace(/[._\s-]/g, '') // Remove dots, underscores, spaces, hyphens
                    .trim();
            }
            
            // Build map with normalized names
            CONFIG.interactiveObjects.forEach((targetNames, stepIndex) => {
                const names = Array.isArray(targetNames) ? targetNames : [targetNames];
                names.forEach(configName => {
                    const normalized = normalizeName(configName);
                    nodeToStepMap.set(normalized, stepIndex);
                    
                    // Also check actual node names and create mappings
                    nodes.forEach(node => {
                        const nodeNormalized = normalizeName(node.name);
                        if (nodeNormalized === normalized || 
                            nodeNormalized.includes(normalized) || 
                            normalized.includes(nodeNormalized)) {
                            // Map both the config name and actual node name
                            nodeToStepMap.set(node.name, stepIndex);
                            nodeToStepMap.set(normalized, stepIndex);
                        }
                    });
                });
            });
            
        }
        
        // Function to find which node was hit using raycasting
        function findHitNode(clientX, clientY) {
            if (!raycaster || !camera || !hierarchyNodes.length) {
                console.warn('findHitNode: Missing required components', {
                    hasRaycaster: !!raycaster,
                    hasCamera: !!camera,
                    hierarchyNodesCount: hierarchyNodes.length
                });
                return null;
            }
            
            // Validate input coordinates
            if (typeof clientX !== 'number' || typeof clientY !== 'number' || 
                isNaN(clientX) || isNaN(clientY)) {
                console.error('findHitNode: Invalid coordinates provided', { clientX, clientY });
                return null;
            }
            
            // Get normalized device coordinates
            const rect = viewer.getBoundingClientRect();
            
            // Account for any page scroll offset
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            // Validate coordinates are within bounds
            if (x < 0 || x > rect.width || y < 0 || y > rect.height) {
                console.warn('findHitNode: Coordinates outside viewer bounds', {
                    clientX, clientY,
                    rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },
                    relative: { x, y }
                });
                return null;
            }
            
            // Convert to normalized device coordinates (-1 to +1)
            const mouse = new THREE.Vector2();
            mouse.x = (x / rect.width) * 2 - 1;
            mouse.y = -(y / rect.height) * 2 + 1;
            
            // Debug logging
            console.log('üîç Raycast at:', { 
                clientX, 
                clientY, 
                relative: { x, y },
                normalized: { x: mouse.x, y: mouse.y },
                viewerSize: { width: rect.width, height: rect.height }
            });
            
            // Get only interactive meshes (exclude ground, table, etc.)
            const interactiveMeshes = hierarchyNodes
                .map(node => node.mesh)
                .filter(mesh => {
                    if (!mesh || !mesh.isMesh) return false;
                    // Filter out non-interactive object names (case-insensitive)
                    const name = (mesh.name || '').toLowerCase();
                    const excludeNames = ['plane', 'ground', 'floor', 'table', 'base', 'surface'];
                    return !excludeNames.some(exclude => name === exclude || name.includes(exclude));
                });
            
            if (interactiveMeshes.length === 0) {
                return null;
            }
            
            // Try to sync camera with model-viewer's camera
            let threeCamera = null;
            if (viewer.renderRoot) {
                const renderer = viewer.renderRoot.querySelector('canvas')?.__THREE__;
                if (renderer) {
                    threeCamera = renderer.camera || renderer.scene?.children.find(child => child.isCamera);
                }
            }
            
            // Update camera to match model-viewer's camera
            if (threeCamera) {
                camera.position.copy(threeCamera.position);
                camera.quaternion.copy(threeCamera.quaternion);
                camera.fov = threeCamera.fov;
                camera.aspect = threeCamera.aspect;
                camera.near = threeCamera.near;
                camera.far = threeCamera.far;
                camera.updateProjectionMatrix();
                camera.updateMatrixWorld();
            } else {
                // Fallback: update aspect ratio
                camera.aspect = viewer.clientWidth / viewer.clientHeight;
                camera.updateProjectionMatrix();
            }
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Perform raycasting ONLY on interactive meshes
            const intersects = raycaster.intersectObjects(interactiveMeshes, true);
            
            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                const distance = intersects[0].distance;
                
                console.log('üéØ Raycast hit:', {
                    meshName: hitMesh.name,
                    distance: distance,
                    point: intersects[0].point,
                    totalIntersects: intersects.length,
                    allHits: intersects.map(i => ({ name: i.object.name, distance: i.distance }))
                });
                
                // Find which node this mesh belongs to
                const hitNode = hierarchyNodes.find(node => {
                    if (node.mesh === hitMesh) return true;
                    // Check parent chain
                    let parent = hitMesh.parent;
                    while (parent) {
                        if (node.mesh === parent) return true;
                        parent = parent.parent;
                    }
                    return false;
                });
                
                if (hitNode) {
                    console.log('‚úÖ Matched to node:', hitNode.name);
                    return hitNode.name;
                } else {
                    console.warn('‚ö†Ô∏è Hit mesh not found in hierarchyNodes:', hitMesh.name);
                }
            } else {
                console.log('‚ùå No raycast intersections found');
            }
            
            return null;
        }


        // ============================================
        // KEYFRAME-BASED PLAYBACK FUNCTIONS
        // ============================================

        // Convert frame number to time in seconds
        function frameToTime(frame, fps = CONFIG.fps) {
            return frame / fps;
        }

        // Play a specific keyframe range
        function playKeyframeRange(stepData) {
            const startTime = frameToTime(stepData.startFrame);
            const endTime = frameToTime(stepData.endFrame);
            
            // Set the start time
            viewer.currentTime = startTime;
            
            // Play the animation
            viewer.play();
            viewer.loop = stepData.loop || false;
            
            // Monitor playback using requestAnimationFrame for smooth control
            function checkPlayback() {
                if (!isAnimating) return; // Stop if user advanced
                
                if (viewer.currentTime >= endTime) {
                    viewer.pause();
                    isAnimating = false;
                    
                    if (stepData.loop) {
                        // Restart this range
                        viewer.currentTime = startTime;
                        viewer.play();
                        requestAnimationFrame(checkPlayback);
                    } else {
                        // Finished
                        if (currentStepIndex < CONFIG.steps.length - 1) {
                            descText.innerText = 'Tap to continue';
                        }
                    }
                } else {
                    requestAnimationFrame(checkPlayback);
                }
            }
            
            requestAnimationFrame(checkPlayback);
        }

        // ============================================
        // OBJECT-SPECIFIC CLICK DETECTION USING MODEL-VIEWER'S CLICK EVENT
        // ============================================

        function getStepIndexForNode(nodeName) {
            if (!nodeName) return -1;
            
            // Try exact match first
            let stepIndex = nodeToStepMap.get(nodeName);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try flexible matching (normalize the name)
            function normalizeName(name) {
                return name.toLowerCase().replace(/[._\s-]/g, '').trim();
            }
            
            const normalized = normalizeName(nodeName);
            stepIndex = nodeToStepMap.get(normalized);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try partial matching
            for (const [mappedName, mappedStep] of nodeToStepMap.entries()) {
                const mappedNormalized = normalizeName(mappedName);
                if (normalized === mappedNormalized || 
                    normalized.includes(mappedNormalized) || 
                    mappedNormalized.includes(normalized)) {
                    return mappedStep;
                }
            }
            
            return -1;
        }

        // ============================================
        // AR AVAILABILITY CHECK & DESKTOP HANDLING
        // ============================================
        
        // Detect mobile devices
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Check if WebXR is available (for desktop AR)
        async function checkWebXRSupport() {
            if (!navigator.xr) {
                return false;
            }
            
            try {
                // Check if immersive-ar session is supported
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                return supported;
            } catch (e) {
                console.log('WebXR check failed:', e);
                return false;
            }
        }
        
        // Handle AR button visibility and errors
        const arButton = document.querySelector('#ar-button');
        const arRecipeCard = document.querySelector('#ar-recipe-card');
        
        // Track current AR mode
        let currentARMode = null;
        let isInQuickLook = false;
        
        // Listen for AR status changes with detailed logging
        viewer.addEventListener('ar-status', (event) => {
            const status = event.detail.status;
            const mode = event.detail.mode;
            currentARMode = mode;
            
            console.log('AR status:', status);
            console.log('AR mode:', mode);
            console.log('AR status detail:', event.detail);
            
            if (status === 'failed') {
                console.error('=== AR INITIALIZATION FAILED ===');
                console.log('Failed AR mode:', mode);
                console.log('AR modes configured:', viewer.arModes);
                console.log('AR available:', viewer.arAvailable);
                console.log('AR supported:', viewer.arSupported);
                console.log('Model loaded:', viewer.loaded);
                console.log('Model source:', viewer.src);
                console.log('iOS source:', viewer.iosSrc);
                console.log('User agent:', navigator.userAgent);
                console.log('Is HTTPS:', location.protocol === 'https:');
                
                // Check for common issues
                if (!viewer.loaded) {
                    console.error('‚ùå Model not loaded - AR cannot initialize');
                }
                if (!viewer.arSupported) {
                    console.error('‚ùå AR not supported on this device/browser');
                }
                if (viewer.arModes && viewer.arModes.length === 0) {
                    console.error('‚ùå No AR modes available');
                }
                if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                    console.error('‚ùå AR requires HTTPS (except localhost)');
                }
                if (mode === 'quick-look' && !viewer.iosSrc) {
                    console.warn('‚ö†Ô∏è Quick Look requires USDZ file for iOS');
                }
                if (mode === 'scene-viewer') {
                    console.log('Scene Viewer failed - checking Android compatibility');
                    console.log('Android version check:', /Android/.test(navigator.userAgent));
                }
                console.log('=== END AR FAILURE DIAGNOSTICS ===');
            } else if (status === 'session-started') {
                console.log('‚úÖ WebXR AR session started!');
                console.log('AR mode:', mode || 'webxr (inferred)');
                
                // Show AR recipe card for WebXR mode
                if (arRecipeCard) {
                    // Force visibility for WebXR DOM overlay
                    arRecipeCard.style.display = 'flex';
                    arRecipeCard.style.position = 'fixed';
                    arRecipeCard.style.bottom = '20px';
                    arRecipeCard.style.left = '50%';
                    arRecipeCard.style.transform = 'translateX(-50%)';
                    arRecipeCard.style.zIndex = '99999';
                    arRecipeCard.style.width = '90%';
                    arRecipeCard.style.maxWidth = '500px';
                    console.log('‚úÖ AR recipe card visibility enabled for WebXR session');
                    console.log('‚úÖ WebXR mode supports HTML overlays (slot="ar-overlay")');
                } else {
                    console.error('‚ùå AR recipe card element not found!');
                }
            } else if (status === 'not-presenting') {
                console.log('AR available but not active');
                isInQuickLook = false;
                
                // Stop auto-play when exiting AR mode
                stopAutoPlay();
                
                // Switch back to original model when exiting AR mode
                if (CONFIG.arModelPath && viewer.src !== CONFIG.modelPath) {
                    console.log('üîÑ Switching back to original model for 3D viewer');
                    viewer.src = CONFIG.modelPath;
                }
                
                // Hide AR recipe card when exiting AR
                if (arRecipeCard) {
                    arRecipeCard.style.display = 'none';
                }
                console.log('AR mode exited - card hidden');
                
                // Make sure button is visible if AR is available
                if (mode === 'webxr' && !isMobileDevice()) {
                    console.log('WebXR mode detected - ensuring AR button is visible');
                    arButton.style.display = '';
                }
            } else if (status === 'presenting') {
                console.log('AR is active!');
                console.log('AR mode:', mode);
                
                // Switch to compressed model for AR mode (better performance)
                if (CONFIG.arModelPath && viewer.src !== CONFIG.arModelPath) {
                    console.log('üîÑ Switching to compressed model for AR mode:', CONFIG.arModelPath);
                    viewer.src = CONFIG.arModelPath;
                }
                
                // AR recipe card visibility - ensure it's visible for WebXR
                // NOTE: slot="ar-overlay" ONLY works with WebXR, NOT Scene Viewer or Quick Look
                if (arRecipeCard) {
                    if (mode === 'webxr' || !mode) {
                        // WebXR mode (or mode not yet determined but status is presenting)
                        console.log('‚úÖ AR presenting - recipe card should be visible via DOM Overlay');
                        console.log('‚úÖ WebXR mode supports HTML overlays (slot="ar-overlay")');
                        // Ensure visibility
                        arRecipeCard.style.display = 'flex';
                        arRecipeCard.style.position = 'fixed';
                        arRecipeCard.style.bottom = '20px';
                        arRecipeCard.style.left = '50%';
                        arRecipeCard.style.transform = 'translateX(-50%)';
                        arRecipeCard.style.zIndex = '99999';
                        console.log('‚úÖ AR recipe card visibility confirmed for WebXR');
                    } else {
                        console.warn('‚ö†Ô∏è Recipe card will NOT appear in', mode, 'mode');
                        console.warn('‚ö†Ô∏è slot="ar-overlay" only works with WebXR');
                        arRecipeCard.style.display = 'none';
                    }
                    console.log('AR status:', status);
                    console.log('AR mode:', mode);
                } else {
                    console.error('‚ùå AR recipe card element not found!');
                }
                
                if (mode === 'quick-look') {
                    isInQuickLook = true;
                    console.log('‚úÖ QUICK LOOK MODE ACTIVE');
                    console.log('üì± Quick Look supports built-in animations from USDZ files');
                    console.log('üìñ See: https://developer.apple.com/augmented-reality/quick-look/');
                    console.log('‚úÖ USDZ file detected:', CONFIG.iosModelPath);
                    console.log('üìã Quick Look banner configured:', CONFIG.iosBanner);
                    console.warn('‚ö†Ô∏è Quick Look does NOT support JavaScript-controlled interactions');
                    console.warn('‚ö†Ô∏è Tap-to-advance (JavaScript) will NOT work in Quick Look');
                    console.log('üé¨ Attempting to play full animation sequence before Quick Look launch...');
                    
                    // Quick Look supports animations that are built into the USDZ file itself
                    // We can try to set up the animation to play the full sequence before Quick Look launches
                    // The animation state might carry over when Quick Look opens
                    try {
                        // Set to play the full animation range (all steps)
                        const firstFrame = CONFIG.steps[0].startFrame;
                        const lastFrame = CONFIG.steps[CONFIG.steps.length - 1].endFrame;
                        const startTime = frameToTime(firstFrame);
                        const endTime = frameToTime(lastFrame);
                        
                        viewer.autoplay = true;
                        viewer.loop = false;
                        viewer.currentTime = startTime;
                        viewer.play();
                        
                        console.log(`‚úÖ Configured animation playback: frames ${firstFrame}-${lastFrame}`);
                        console.log(`‚úÖ Animation duration: ${(endTime - startTime).toFixed(2)}s`);
                        console.log('üí° If USDZ has animations configured, they should play automatically in Quick Look');
                    } catch (e) {
                        console.warn('Could not configure animation playback:', e);
                    }
                    
                    setTimeout(() => {
                        descText.innerText = 'Quick Look: Animation should play automatically from USDZ file';
                        titleText.innerText = 'AR Experience';
                    }, 500);
                } else if (mode === 'webxr') {
                    isInQuickLook = false;
                    console.log('‚úÖ WebXR AR session started successfully!');
                    console.log('‚úÖ JavaScript interactions ARE supported in WebXR mode.');
                    console.log('üé¨ Starting automatic animation playback in AR mode...');
                    
                    // Enable autoplay for AR mode
                    viewer.autoplay = true;
                    viewer.loop = false;
                    viewer.currentTime = frameToTime(1);
                    viewer.play();
                    
                    // Start auto-play in AR mode
                    setTimeout(() => {
                        playAllStepsAuto();
                    }, 1000); // Small delay to ensure AR is fully initialized
                } else if (mode === 'scene-viewer') {
                    isInQuickLook = false;
                    console.log('‚úÖ Scene Viewer AR active (Android)');
                    console.warn('‚ö†Ô∏è Scene Viewer may have limited JavaScript support.');
                    console.log('üìã Scene Viewer banner configured via link attribute:', viewer.link);
                    console.log('üìã Scene Viewer title:', viewer.title);
                    console.log('üí° Scene Viewer 1.1+ supports visit button/banner via link parameter');
                    console.log('üí° The banner should appear as a "Visit" button in Scene Viewer');
                    console.warn('‚ö†Ô∏è HTML overlays (slot="ar-overlay") do NOT work in Scene Viewer');
                    console.log('üé¨ Starting automatic animation playback in AR mode...');
                    
                    // Enable autoplay for AR mode
                    viewer.autoplay = true;
                    viewer.loop = false;
                    viewer.currentTime = frameToTime(1);
                    viewer.play();
                    
                    // Start auto-play in AR mode (may work depending on Android version)
                    setTimeout(() => {
                        playAllStepsAuto();
                    }, 1000); // Small delay to ensure AR is fully initialized
                }
            }
        });
        
        // Catch AR launch errors (like the Intent URL error on desktop)
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('intent://')) {
                console.warn('AR Intent URL not supported on this device');
                if (!isMobileDevice()) {
                    console.info('Scene Viewer (Android) requires a mobile device.');
                    console.info('WebXR AR may still be available - try clicking the AR button.');
                }
            }
        });

        // ============================================
        // iOS QUICK LOOK BANNER TAP LISTENER
        // ============================================
        // Listen for banner taps in Quick Look
        // According to Variant 3D docs, taps trigger a 'message' event
        // See: https://www.variant3d.com/blog/using-banners-in-quicklooks
        viewer.addEventListener('message', (event) => {
            if (event.data === '_apple_ar_quicklook_button_tapped') {
                console.log('üîó iOS Quick Look banner tapped!');
                console.log('User tapped the banner button - redirecting to recipe page');
                // The banner will automatically redirect via canonicalWebPageURL
                // But we can also track this event for analytics
            }
        });
        
        // Check AR availability after model loads
        viewer.addEventListener('load', async () => {
            console.log('Model loaded, checking AR availability...');
            console.log('AR available:', viewer.arAvailable);
            console.log('AR supported:', viewer.arSupported);
            console.log('AR modes:', viewer.arModes);
            console.log('Model loaded:', viewer.loaded);
            console.log('Model source:', viewer.src);
            console.log('iOS source:', viewer.iosSrc);
            
            const isMobile = isMobileDevice();
            
            // Wait a bit longer for AR to initialize, especially WebXR on desktop
            setTimeout(async () => {
                // Check WebXR support for desktop
                let webXRSupported = false;
                if (!isMobile) {
                    webXRSupported = await checkWebXRSupport();
                    console.log('WebXR support check:', webXRSupported);
                    console.log('Protocol:', location.protocol);
                    console.log('Hostname:', location.hostname);
                    
                    if (webXRSupported) {
                        console.log('‚úÖ WebXR is available! Desktop AR should work.');
                        console.log('Requirements:');
                        console.log('- HTTPS or localhost:', location.protocol === 'https:' || location.hostname === 'localhost');
                        console.log('- Chrome/Edge browser recommended');
                        console.log('- Camera permissions will be requested');
                    } else {
                        console.log('‚ö†Ô∏è WebXR not available on desktop');
                        console.log('To enable WebXR:');
                        console.log('1. Use Chrome or Edge browser');
                        console.log('2. Ensure HTTPS (or localhost)');
                        console.log('3. Check chrome://flags/#webxr-incubations (if needed)');
                    }
                }
                
                // Only hide button if AR is not available AND WebXR is not supported (on desktop)
                if (!viewer.arAvailable && !isMobile && !webXRSupported) {
                    console.log('Hiding AR button - no AR support detected');
                    arButton.style.display = 'none';
                } else if (!viewer.arAvailable && !isMobile && webXRSupported) {
                    console.log('Keeping AR button visible - WebXR detected');
                    arButton.style.display = '';
                }
                
                // Log AR capabilities
                if (isMobile) {
                    console.log('Mobile device detected');
                    console.log('AR available:', viewer.arAvailable);
                    console.log('AR supported:', viewer.arSupported);
                    
                    // Check WebXR support on mobile too (for Android)
                    const mobileWebXRSupported = await checkWebXRSupport();
                    console.log('WebXR support on mobile:', mobileWebXRSupported);
                    
                    if (mobileWebXRSupported) {
                        console.log('‚úÖ WebXR IS available on this mobile device!');
                        console.log('üí° WebXR should be prioritized over Scene Viewer');
                        console.log('üí° WebXR supports HTML overlays (slot="ar-overlay")');
                        console.log('‚ö†Ô∏è If Scene Viewer launches instead, the recipe card will NOT appear');
                    } else {
                        console.warn('‚ö†Ô∏è WebXR NOT available on this mobile device');
                        console.warn('‚ö†Ô∏è Will fall back to Scene Viewer (Android) or Quick Look (iOS)');
                        console.warn('‚ö†Ô∏è Scene Viewer does NOT support HTML overlays');
                        console.warn('‚ö†Ô∏è Recipe card will NOT appear in Scene Viewer mode');
                    }
                    
                    if (!viewer.arAvailable) {
                        console.warn('AR not available on this mobile device');
                        console.log('Possible reasons:');
                        console.log('1. Browser does not support AR');
                        console.log('2. Model file too large');
                        console.log('3. Missing USDZ file (for iOS)');
                        console.log('4. Camera permissions not granted');
                        console.log('5. Device does not support AR');
                    }
                } else {
                    console.log('Desktop device detected');
                    console.log('AR available (model-viewer):', viewer.arAvailable);
                    console.log('WebXR available:', webXRSupported);
                    if (viewer.arAvailable || webXRSupported) {
                        console.log('‚úÖ AR should work on this desktop browser');
                    }
                }
            }, 2000); // Increased timeout to allow WebXR to initialize
        });

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentStepIndex = -1; // Starts before the first step
        let isAnimating = false;

        // ============================================
        // EVENT HANDLERS
        // ============================================

        // ============================================
        // DEBUG: Log non-click events (click events handled separately)
        // ============================================
        const eventsToLog = ['ar-status', 'load', 'model-load', 'error', 'scene-graph-ready'];
        eventsToLog.forEach(eventType => {
            viewer.addEventListener(eventType, (e) => {
                console.log(`[${eventType}] event fired`);
                if (e.detail && typeof e.detail === 'object') {
                    console.log(`[${eventType}] event.detail:`, e.detail);
                }
            });
        });

        // Track last click to prevent duplicate processing
        let lastClickTime = 0;
        let lastClickCoords = { x: null, y: null };
        const CLICK_DEBOUNCE_MS = 100; // Prevent rapid duplicate clicks
        
        // OBJECT-SPECIFIC CLICK HANDLER USING RAYCASTING
        viewer.addEventListener('click', (event) => {
            const now = Date.now();
            
            console.log('Click event fired!', {
                target: event.target,
                type: event.type,
                isTrusted: event.isTrusted, // Check if it's a real user interaction
                isInQuickLook: isInQuickLook,
                currentARMode: currentARMode,
                hasRaycaster: !!raycaster,
                hierarchyNodesCount: hierarchyNodes.length
            });
            
            // Only process trusted events (real user interactions)
            if (!event.isTrusted) {
                console.warn('‚ö†Ô∏è Ignoring non-trusted event (programmatic click)');
                return;
            }
            
            // Warn if in Quick Look mode
            if (isInQuickLook) {
                console.warn('‚ö†Ô∏è Click detected but Quick Look does not support JavaScript interactions');
                return;
            }
            
            // If auto-play is running in AR mode, stop it and switch to manual control
            if (isAutoPlaying && currentARMode && currentARMode !== 'not-presenting') {
                console.log('üõë User tap detected - stopping auto-play and switching to manual control');
                stopAutoPlay();
            }
            
            // Ignore if animating (unless it's a looping step)
            if (isAnimating && !CONFIG.steps[currentStepIndex]?.loop) {
                console.log('Ignoring click - animation in progress');
                return;
            }
            
            // Ignore AR button clicks
            if (event.target && (event.target.id === 'ar-button' || event.target.closest('#ar-button'))) {
                console.log('Ignoring click - AR button');
                return;
            }
            
            // Get coordinates - handle both mouse and touch events
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                // Touch event
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                // Touch event (changedTouches for touchend)
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                // Mouse event
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            // VALIDATION: Ensure coordinates are valid numbers
            if (typeof clientX !== 'number' || typeof clientY !== 'number' || 
                isNaN(clientX) || isNaN(clientY)) {
                console.warn('‚ö†Ô∏è Invalid coordinates detected:', { clientX, clientY });
                console.warn('Event details:', {
                    hasTouches: !!event.touches,
                    touchesLength: event.touches?.length,
                    hasChangedTouches: !!event.changedTouches,
                    changedTouchesLength: event.changedTouches?.length,
                    clientX: event.clientX,
                    clientY: event.clientY
                });
                return;
            }
            
            // VALIDATION: Ensure coordinates are within viewer bounds
            const rect = viewer.getBoundingClientRect();
            const relativeX = clientX - rect.left;
            const relativeY = clientY - rect.top;
            
            if (relativeX < 0 || relativeX > rect.width || relativeY < 0 || relativeY > rect.height) {
                console.log('Click outside viewer bounds, ignoring:', {
                    clientX, clientY,
                    rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },
                    relative: { x: relativeX, y: relativeY }
                });
                return;
            }
            
            console.log('‚úÖ Valid click coordinates:', { 
                clientX, 
                clientY,
                relativeX,
                relativeY,
                viewerSize: { width: rect.width, height: rect.height }
            });
            
            // Debounce: Prevent processing duplicate clicks at same location
            const timeSinceLastClick = now - lastClickTime;
            const sameLocation = lastClickCoords.x === clientX && lastClickCoords.y === clientY;
            
            if (timeSinceLastClick < CLICK_DEBOUNCE_MS && sameLocation) {
                console.log('‚ö†Ô∏è Ignoring duplicate click at same location:', {
                    timeSinceLastClick,
                    coords: { x: clientX, y: clientY }
                });
                return;
            }
            
            // Update last click tracking
            lastClickTime = now;
            lastClickCoords = { x: clientX, y: clientY };
            
            // Check if raycasting is ready
            if (!raycaster || !hierarchyNodes.length) {
                console.warn('‚ö†Ô∏è Raycasting not ready:', {
                    hasRaycaster: !!raycaster,
                    hierarchyNodesCount: hierarchyNodes.length
                });
                descText.innerText = 'Loading... Please wait for model to initialize.';
                return;
            }
            
            // Use raycasting to find hit node
            let nodeName = null;
            try {
                nodeName = findHitNode(clientX, clientY);
            } catch (error) {
                console.error('Error in findHitNode:', error);
                return;
            }
            
            // Log the node name for debugging (preserve the name)
            if (nodeName) {
                console.log('‚úÖ Hit node:', nodeName);
            } else {
                console.log('‚ùå No node hit at coordinates:', { clientX, clientY });
            }
            
            if (!nodeName) {
                // Clicked on empty space - show feedback
                descText.innerText = 'Tap to continue';
                return;
            }
            
            // Find which step this node belongs to
            const objectStepIndex = getStepIndexForNode(nodeName);
            console.log('Node maps to step:', objectStepIndex);
            
            if (objectStepIndex === -1) {
                // Clicked node is not interactive
                console.log('Node is not in interactive objects list:', nodeName);
                descText.innerText = 'Tap to continue';
                return;
            }
            
            // Check if this is the correct step to advance
            const expectedStepIndex = currentStepIndex + 1;
            
            if (objectStepIndex === expectedStepIndex) {
                // Correct object clicked - advance!
                console.log('‚úÖ Correct object clicked! Advancing to step', expectedStepIndex);
                playNextStep();
            } else if (objectStepIndex < expectedStepIndex) {
                // Clicked an object from a previous step
                console.log('‚ö†Ô∏è Clicked previous step object');
                descText.innerText = 'Tap to continue';
            } else {
                // Clicked an object from a future step
                console.log('‚ö†Ô∏è Clicked future step object');
                descText.innerText = 'Tap to continue';
            }
        });
        
        // Also listen for touchstart/touchend to catch mobile taps
        viewer.addEventListener('touchstart', (event) => {
            console.log('Touchstart event fired');
            // Let the click handler process it
        });
        
        viewer.addEventListener('touchend', (event) => {
            console.log('Touchend event fired');
            // Let the click handler process it
        });

        // ============================================
        // WELCOME CARD CLICK HANDLER (for in-browser 3D viewer)
        // ============================================
        
        // Make the welcome card clickable to trigger animations
        if (card) {
            card.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent event from bubbling to viewer
                
                // Only work in non-AR mode (object mode / 3D viewer)
                if (currentARMode && currentARMode !== 'not-presenting') {
                    console.log('Card click ignored - AR mode is active');
                    return;
                }
                
                // Ignore if animating (unless it's a looping step)
                if (isAnimating && !CONFIG.steps[currentStepIndex]?.loop) {
                    console.log('Card click ignored - animation in progress');
                    return;
                }
                
                console.log('üé¨ Welcome card clicked - triggering next animation step');
                
                // Check if we're at the start or need to advance
                if (currentStepIndex < CONFIG.steps.length - 1) {
                    // Advance to next step
                    playNextStep();
                } else {
                    // All steps completed - restart
                    console.log('All steps completed - restarting experience');
                    resetExperience();
                    // Then play first step
                    setTimeout(() => {
                        playNextStep();
                    }, 100);
                }
            });
            
            console.log('‚úÖ Welcome card click handler attached');
        }

        // ============================================
        // AR RECIPE CARD HANDLER
        // ============================================
        
        // Handle AR recipe card clicks (opens in new tab)
        // Note: Card is now inside model-viewer with slot="ar-overlay"
        // so it's automatically projected onto the AR camera feed via WebXR DOM Overlay
        if (arRecipeCard) {
            // Prevent clicks on card from bubbling to viewer
            arRecipeCard.addEventListener('click', (event) => {
                event.stopPropagation();
            });
            
            // Log when recipe is accessed
            const recipeLinks = arRecipeCard.querySelectorAll('a');
            recipeLinks.forEach(link => {
                link.addEventListener('click', () => {
                    console.log('üîó AR Recipe clicked - opening Nescaf√© Dalgona recipe');
                });
            });
            
            console.log('‚úÖ AR recipe card handlers attached (WebXR DOM Overlay)');
        }

        // ============================================
        // PLAYBACK FUNCTIONS
        // ============================================

        function playNextStep() {
            currentStepIndex++;
            const stepData = CONFIG.steps[currentStepIndex];

            // Update UI
            titleText.innerText = stepData.title;
            descText.innerText = 'Tap to continue'; // Always show this since raycasting is buggy
            isAnimating = true;

            // Play the keyframe range
            playKeyframeRange(stepData);
        }

        function resetExperience() {
            currentStepIndex = -1;
            titleText.innerText = CONFIG.resetTitle;
            descText.innerText = CONFIG.resetDesc;
            
            // Reset to first frame
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            isAnimating = false;
        }

        // Auto-play all steps in sequence (for AR mode)
        let autoPlayTimeout = null;
        let isAutoPlaying = false;

        function playAllStepsAuto() {
            if (isAutoPlaying) {
                console.log('Auto-play already in progress');
                return;
            }

            console.log('üé¨ Starting auto-play sequence in AR mode');
            isAutoPlaying = true;
            
            // Reset to beginning
            currentStepIndex = -1;
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            isAnimating = false;

            // Start playing steps automatically
            function playNextAutoStep() {
                if (currentStepIndex >= CONFIG.steps.length - 1) {
                    // All steps completed
                    console.log('‚úÖ Auto-play sequence completed');
                    isAutoPlaying = false;
                    const lastStep = CONFIG.steps[CONFIG.steps.length - 1];
                    titleText.innerText = lastStep.title;
                    descText.innerText = 'Animation complete!';
                    
                    // Recipe link doesn't need reset (it's just a link)
                    return;
                }

                // Advance to next step
                currentStepIndex++;
                const stepData = CONFIG.steps[currentStepIndex];
                
                console.log(`üé¨ Auto-playing step ${currentStepIndex + 1}/${CONFIG.steps.length}: ${stepData.title}`);

                // Update UI
                titleText.innerText = stepData.title;
                descText.innerText = 'Tap to continue'; // Always show this since raycasting is buggy
                isAnimating = true;

                // Play the keyframe range
                const startTime = frameToTime(stepData.startFrame);
                const endTime = frameToTime(stepData.endFrame);
                
                viewer.currentTime = startTime;
                viewer.play();
                viewer.loop = stepData.loop || false;

                // Calculate duration for this step
                const stepDuration = (endTime - startTime) * 1000; // Convert to milliseconds

                // Monitor playback and advance to next step when done
                function checkAutoPlayback() {
                    if (!isAutoPlaying) return; // Stop if auto-play was cancelled

                    if (viewer.currentTime >= endTime) {
                        viewer.pause();
                        isAnimating = false;
                        
                        // Wait a brief moment before next step, then continue
                        autoPlayTimeout = setTimeout(() => {
                            playNextAutoStep();
                        }, 500); // 500ms pause between steps
                    } else {
                        requestAnimationFrame(checkAutoPlayback);
                    }
                }
                
                requestAnimationFrame(checkAutoPlayback);
            }

            // Start the sequence after a short delay
            setTimeout(() => {
                playNextAutoStep();
            }, 1000); // 1 second delay before starting
        }

        function stopAutoPlay() {
            if (autoPlayTimeout) {
                clearTimeout(autoPlayTimeout);
                autoPlayTimeout = null;
            }
            isAutoPlaying = false;
            isAnimating = false;
            console.log('‚èπÔ∏è Auto-play stopped');
            
                    // Recipe link doesn't need reset (it's just a link)
        }

        // ============================================
        // ERROR HANDLING
        // ============================================
        
        viewer.addEventListener('error', (event) => {
            console.error('Model loading error:', event.detail);
            titleText.innerText = 'Error';
            descText.innerText = 'Failed to load 3D model. Check console for details.';
        });

        viewer.addEventListener('load', () => {
            console.log('Model loaded successfully');
            console.log('Click handler ready:', {
                hasRaycaster: !!raycaster,
                hierarchyNodesCount: hierarchyNodes.length,
                currentStepIndex: currentStepIndex,
                totalSteps: CONFIG.steps.length
            });
            
            // Test click detection setup
            if (!raycaster || !hierarchyNodes.length) {
                console.warn('‚ö†Ô∏è Click detection not fully initialized. Retrying...');
                setTimeout(() => {
                    setupHitDetection();
                }, 500);
            } else {
                console.log('‚úÖ Click detection ready! Try tapping objects.');
            }
        });

        // ============================================
        // HELPER: Debug object names
        // ============================================

        // Uncomment to debug object names:
        // viewer.addEventListener('load', () => {
        //     const scene = viewer.getScene();
        //     console.log('=== All Objects in Model ===');
        //     scene.traverse((object) => {
        //         if (object.isMesh) {
        //             console.log(`Name: "${object.name}", Type: ${object.type}`);
        //         }
        //     });
        // });

    </script>
</body>
</html>
