<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tap-to-Advance AR Experience</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    
    <style>
        /* --- CSS STYLING --- */
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Helvetica', 'Arial', sans-serif; 
            overflow: hidden; 
        }
        
        /* The AR Window */
        model-viewer {
            width: 100vw;
            height: 100vh;
            background-color: #f5f5f5; /* Fallback color */
            --poster-color: #f5f5f5;
        }

        /* The UI Overlay Container */
        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Let taps pass through to the 3D model */
            z-index: 100;
        }

        /* The Branding / Instruction Card */
        .card {
            display: inline-block;
            background: white;
            padding: 16px 24px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .card h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card p {
            margin: 4px 0 0 0;
            font-size: 14px;
            color: #555;
        }

        /* Hide UI while loading */
        model-viewer:not([loaded]) #ui-layer { 
            opacity: 0; 
        }

        /* Custom AR Button Styling */
        #ar-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 200;
            cursor: pointer;
            transition: background 0.2s;
        }

        #ar-button:hover {
            background: #0056CC;
        }
    </style>
</head>
<body>

    <model-viewer 
        id="ar-viewer"
        src="assets/Dalgona-OneTake_0001.glb"
        ar
        ar-modes="scene-viewer quick-look webxr"
        camera-controls
        disable-tap
        shadow-intensity="1.2"
        environment-image="assets/ostrich_road_1k.exr" 
        tone-mapping="commerce"
        animation-name="animation_0"
        autoplay="false">
        
        <button slot="ar-button" id="ar-button">
            View in your space
        </button>
    </model-viewer>

    <div id="ui-layer">
        <div class="card" id="info-card">
            <h2 id="step-title">Welcome</h2>
            <p id="step-desc">Tap the Nescafé sachet to start!</p>
        </div>
    </div>

    <script type="module">
        // ============================================
        // ON-SCREEN CONSOLE FOR MOBILE DEBUGGING
        // ============================================
        
        function createOnScreenConsole() {
            const consoleDiv = document.createElement('div');
            consoleDiv.id = 'mobile-console';
            consoleDiv.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 200px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.95);
                color: #0f0;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 8px;
                z-index: 10000;
                display: none;
                border-top: 2px solid #0f0;
                box-shadow: 0 -2px 10px rgba(0, 255, 0, 0.3);
            `;
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '✕';
            closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: #f00;
                color: white;
                border: none;
                border-radius: 3px;
                width: 24px;
                height: 24px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                z-index: 10001;
            `;
            closeBtn.onclick = () => {
                consoleDiv.style.display = 'none';
            };
            consoleDiv.appendChild(closeBtn);
            
            // Add clear button
            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 35px;
                background: #333;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 8px;
                cursor: pointer;
                font-size: 10px;
                z-index: 10001;
            `;
            clearBtn.onclick = () => {
                const logs = consoleDiv.querySelectorAll('div:not(button)');
                logs.forEach(log => log.remove());
            };
            consoleDiv.appendChild(clearBtn);
            
            document.body.appendChild(consoleDiv);
            
            // Store original console methods
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;
            
            function addToScreen(type, ...args) {
                const consoleDiv = document.getElementById('mobile-console');
                if (!consoleDiv) return;
                
                const message = args.map(arg => {
                    if (arg === null) return 'null';
                    if (arg === undefined) return 'undefined';
                    if (typeof arg === 'object') {
                        try {
                            return JSON.stringify(arg, null, 2);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return String(arg);
                }).join(' ');
                
                const logEntry = document.createElement('div');
                logEntry.style.cssText = `
                    padding: 3px 0;
                    border-bottom: 1px solid #222;
                    word-wrap: break-word;
                    color: ${type === 'error' ? '#ff4444' : type === 'warn' ? '#ffaa00' : type === 'info' ? '#00aaff' : '#00ff00'};
                    white-space: pre-wrap;
                `;
                
                const timestamp = new Date().toLocaleTimeString();
                logEntry.textContent = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
                consoleDiv.appendChild(logEntry);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                
                // Auto-show console for errors and warnings
                if (type === 'error' || type === 'warn') {
                    consoleDiv.style.display = 'block';
                }
            }
            
            // Override console methods
            console.log = function(...args) {
                originalLog.apply(console, args);
                addToScreen('log', ...args);
            };
            
            console.error = function(...args) {
                originalError.apply(console, args);
                addToScreen('error', ...args);
            };
            
            console.warn = function(...args) {
                originalWarn.apply(console, args);
                addToScreen('warn', ...args);
            };
            
            console.info = function(...args) {
                if (originalInfo) originalInfo.apply(console, args);
                addToScreen('info', ...args);
            };
            
            // Toggle console with triple tap
            let tapCount = 0;
            let tapTimer = null;
            document.addEventListener('touchstart', (e) => {
                // Don't trigger on UI elements
                if (e.target.tagName === 'BUTTON' || e.target.closest('#ui-layer')) {
                    return;
                }
                
                tapCount++;
                clearTimeout(tapTimer);
                tapTimer = setTimeout(() => {
                    if (tapCount === 3) {
                        const consoleDiv = document.getElementById('mobile-console');
                        if (consoleDiv) {
                            consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                        }
                    }
                    tapCount = 0;
                }, 400);
            });
            
            // Also allow keyboard toggle (for desktop testing)
            document.addEventListener('keydown', (e) => {
                if (e.key === '`' && e.ctrlKey) {
                    e.preventDefault();
                    const consoleDiv = document.getElementById('mobile-console');
                    if (consoleDiv) {
                        consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                    }
                }
            });
            
            console.log('On-screen console initialized. Triple-tap to toggle, or press Ctrl+`');
        }
        
        // Initialize console immediately
        createOnScreenConsole();
        
        // ============================================
        // CONFIGURATION: Keyframe-based animation with object-specific taps
        // ============================================
        
        const CONFIG = {
            // Path to your 3D model (GLB format)
            modelPath: 'assets/Dalgona-OneTake_0001.glb',
            
            // Path to iOS USDZ format (optional, for better iOS support)
            // Note: USDZ file not present, iOS will use GLB
            iosModelPath: null,
            
            // Animation name (single track)
            animationName: 'animation_0',
            
            // Frame rate of your animation
            fps: 30,
            
            // Keyframe spans for each step
            steps: [
                { 
                    startFrame: 1,
                    endFrame: 80,
                    title: 'Step 1: The Mix', 
                    desc: 'Nescafé + Water into bowl',
                    objectHint: 'Tap the Nescafé sachet, pot, or handle'
                },
                { 
                    startFrame: 80,
                    endFrame: 140,
                    title: 'Step 2: Whip It', 
                    desc: 'Whisking into foam...',
                    objectHint: 'Tap the whisk'
                },
                { 
                    startFrame: 140,
                    endFrame: 200,
                    title: 'Step 3: The Base', 
                    desc: 'Milk into mug...',
                    objectHint: 'Tap the jug'
                },
                { 
                    startFrame: 200,
                    endFrame: 240,
                    title: 'Step 4: Transfer', 
                    desc: 'Bowl into mug...',
                    objectHint: 'Tap the mixing bowl'
                },
                { 
                    startFrame: 240,
                    endFrame: 300,
                    title: 'Step 5: Final Touch', 
                    desc: 'Add ice...',
                    objectHint: 'Tap the scoop or ice bowl',
                    loop: false
                }
            ],
            
            // Object names that trigger each step (will be matched flexibly against GLB node names)
            // Note: Matching is flexible - handles dots/underscores, spaces/underscores, case variations
            interactiveObjects: [
                ['NescafeBTM', 'NescafeTOP_(Copy)', 'NescafeTOP', 'teapot', 'pot', 'handle'],  // Step 1
                ['whisk'],                                                // Step 2
                ['jug'],                                                  // Step 3
                ['mixingbowl', 'mixing.bowl'],                            // Step 4
                ['scoop', 'icebowl', 'ice.bowl']                          // Step 5
            ],
            
            // Welcome message
            welcomeTitle: 'Welcome',
            welcomeDesc: 'Tap the Nescafé sachet to start!',
            
            // Continue prompt
            continuePrompt: 'Tap the correct object to continue ->',
            
            // Reset message
            resetTitle: 'Replay?',
            resetDesc: 'Tap to start again.',
            
            // Visual feedback for interactive objects
            enableHoverFeedback: true
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        
        const viewer = document.querySelector('#ar-viewer');
        const titleText = document.querySelector('#step-title');
        const descText = document.querySelector('#step-desc');
        const card = document.querySelector('#info-card');

        // Set model paths from config
        viewer.src = CONFIG.modelPath;
        // Only set iOS source if it exists (USDZ provides better iOS Quick Look support)
        if (CONFIG.iosModelPath) {
            viewer.setAttribute('ios-src', CONFIG.iosModelPath);
        } else {
            console.log('No USDZ file specified - iOS will use GLB (may have limitations)');
        }
        viewer.animationName = CONFIG.animationName;
        viewer.autoplay = false;
        viewer.loop = false;

        // Set welcome message
        titleText.innerText = CONFIG.welcomeTitle;
        descText.innerText = CONFIG.welcomeDesc;

        // ============================================
        // MODEL-VIEWER CLICK EVENT SETUP
        // ============================================
        
        // Map of node names to step indices (with flexible matching)
        let nodeToStepMap = new Map();
        let hierarchyNodes = []; // Store hierarchy nodes with meshes
        let THREE = null; // Will store Three.js reference
        let raycaster = null;
        let camera = null;
        
        // Initialize after model loads
        viewer.addEventListener('load', () => {
            // Set initial time to frame 1
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            
            // Access hierarchy and build mappings
            setupHitDetection();
        });
        
        // Also listen for scene-graph-ready event
        viewer.addEventListener('scene-graph-ready', () => {
            console.log('Scene graph ready');
            setupHitDetection();
        });
        
        function setupHitDetection() {
            // Import Three.js for raycasting
            if (!window.THREE) {
                import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js').then((THREE_Module) => {
                    window.THREE = THREE_Module;
                    THREE = THREE_Module;
                    initializeHitDetection();
                }).catch((err) => {
                    console.error('Failed to import Three.js:', err);
                });
            } else {
                THREE = window.THREE;
                initializeHitDetection();
            }
        }
        
        function initializeHitDetection() {
            if (!THREE) {
                console.error('Three.js not available');
                return;
            }
            
            // Access hierarchy from viewer.model
            const symbols = Object.getOwnPropertySymbols(viewer.model);
            const hierarchySym = symbols.find(s => s.toString().includes('hierarchy'));
            
            if (!hierarchySym) {
                console.error('Could not find hierarchy Symbol');
                return;
            }
            
            const hierarchy = viewer.model[hierarchySym];
            hierarchyNodes = hierarchy.filter(node => node.mesh); // Only nodes with meshes
            
            // Build flexible node-to-step mapping
            buildFlexibleNodeMapping(hierarchyNodes);
            
            // Initialize raycasting
            raycaster = new THREE.Raycaster();
            
            // Create camera for raycasting
            // Will be updated on each click to match model-viewer's camera
            camera = new THREE.PerspectiveCamera(
                75,
                viewer.clientWidth / viewer.clientHeight,
                0.1,
                1000
            );
            
            // Store reference to model-viewer's scene for easier access
            // Try to access through renderRoot
            if (viewer.renderRoot) {
                const canvas = viewer.renderRoot.querySelector('canvas');
                if (canvas && canvas.__THREE__) {
                    window.modelViewerScene = canvas.__THREE__.scene;
                    window.modelViewerCamera = canvas.__THREE__.camera;
                }
            }
        }
        
        function buildFlexibleNodeMapping(nodes) {
            // Normalize function to handle variations
            function normalizeName(name) {
                if (!name) return '';
                return name
                    .toLowerCase()
                    .replace(/[._\s-]/g, '') // Remove dots, underscores, spaces, hyphens
                    .trim();
            }
            
            // Build map with normalized names
            CONFIG.interactiveObjects.forEach((targetNames, stepIndex) => {
                const names = Array.isArray(targetNames) ? targetNames : [targetNames];
                names.forEach(configName => {
                    const normalized = normalizeName(configName);
                    nodeToStepMap.set(normalized, stepIndex);
                    
                    // Also check actual node names and create mappings
                    nodes.forEach(node => {
                        const nodeNormalized = normalizeName(node.name);
                        if (nodeNormalized === normalized || 
                            nodeNormalized.includes(normalized) || 
                            normalized.includes(nodeNormalized)) {
                            // Map both the config name and actual node name
                            nodeToStepMap.set(node.name, stepIndex);
                            nodeToStepMap.set(normalized, stepIndex);
                        }
                    });
                });
            });
            
        }
        
        // Function to find which node was hit using raycasting
        function findHitNode(clientX, clientY) {
            if (!raycaster || !camera || !hierarchyNodes.length) {
                return null;
            }
            
            // Get normalized device coordinates
            const rect = viewer.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            // Get only interactive meshes (exclude ground, table, etc.)
            const interactiveMeshes = hierarchyNodes
                .map(node => node.mesh)
                .filter(mesh => {
                    if (!mesh || !mesh.isMesh) return false;
                    // Filter out non-interactive object names (case-insensitive)
                    const name = (mesh.name || '').toLowerCase();
                    const excludeNames = ['plane', 'ground', 'floor', 'table', 'base', 'surface'];
                    return !excludeNames.some(exclude => name === exclude || name.includes(exclude));
                });
            
            if (interactiveMeshes.length === 0) {
                return null;
            }
            
            // Try to sync camera with model-viewer's camera
            let threeCamera = null;
            if (viewer.renderRoot) {
                const renderer = viewer.renderRoot.querySelector('canvas')?.__THREE__;
                if (renderer) {
                    threeCamera = renderer.camera || renderer.scene?.children.find(child => child.isCamera);
                }
            }
            
            // Update camera to match model-viewer's camera
            if (threeCamera) {
                camera.position.copy(threeCamera.position);
                camera.quaternion.copy(threeCamera.quaternion);
                camera.fov = threeCamera.fov;
                camera.aspect = threeCamera.aspect;
                camera.near = threeCamera.near;
                camera.far = threeCamera.far;
                camera.updateProjectionMatrix();
                camera.updateMatrixWorld();
            } else {
                // Fallback: update aspect ratio
                camera.aspect = viewer.clientWidth / viewer.clientHeight;
                camera.updateProjectionMatrix();
            }
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Perform raycasting ONLY on interactive meshes
            const intersects = raycaster.intersectObjects(interactiveMeshes, true);
            
            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                
                // Find which node this mesh belongs to
                const hitNode = hierarchyNodes.find(node => {
                    if (node.mesh === hitMesh) return true;
                    // Check parent chain
                    let parent = hitMesh.parent;
                    while (parent) {
                        if (node.mesh === parent) return true;
                        parent = parent.parent;
                    }
                    return false;
                });
                
                if (hitNode) {
                    return hitNode.name;
                }
            }
            
            return null;
        }


        // ============================================
        // KEYFRAME-BASED PLAYBACK FUNCTIONS
        // ============================================

        // Convert frame number to time in seconds
        function frameToTime(frame, fps = CONFIG.fps) {
            return frame / fps;
        }

        // Play a specific keyframe range
        function playKeyframeRange(stepData) {
            const startTime = frameToTime(stepData.startFrame);
            const endTime = frameToTime(stepData.endFrame);
            
            // Set the start time
            viewer.currentTime = startTime;
            
            // Play the animation
            viewer.play();
            viewer.loop = stepData.loop || false;
            
            // Monitor playback using requestAnimationFrame for smooth control
            function checkPlayback() {
                if (!isAnimating) return; // Stop if user advanced
                
                if (viewer.currentTime >= endTime) {
                    viewer.pause();
                    isAnimating = false;
                    
                    if (stepData.loop) {
                        // Restart this range
                        viewer.currentTime = startTime;
                        viewer.play();
                        requestAnimationFrame(checkPlayback);
                    } else {
                        // Finished
                        if (currentStepIndex < CONFIG.steps.length - 1) {
                            descText.innerText = CONFIG.continuePrompt;
                        }
                    }
                } else {
                    requestAnimationFrame(checkPlayback);
                }
            }
            
            requestAnimationFrame(checkPlayback);
        }

        // ============================================
        // OBJECT-SPECIFIC CLICK DETECTION USING MODEL-VIEWER'S CLICK EVENT
        // ============================================

        function getStepIndexForNode(nodeName) {
            if (!nodeName) return -1;
            
            // Try exact match first
            let stepIndex = nodeToStepMap.get(nodeName);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try flexible matching (normalize the name)
            function normalizeName(name) {
                return name.toLowerCase().replace(/[._\s-]/g, '').trim();
            }
            
            const normalized = normalizeName(nodeName);
            stepIndex = nodeToStepMap.get(normalized);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try partial matching
            for (const [mappedName, mappedStep] of nodeToStepMap.entries()) {
                const mappedNormalized = normalizeName(mappedName);
                if (normalized === mappedNormalized || 
                    normalized.includes(mappedNormalized) || 
                    mappedNormalized.includes(normalized)) {
                    return mappedStep;
                }
            }
            
            return -1;
        }

        // ============================================
        // AR AVAILABILITY CHECK & DESKTOP HANDLING
        // ============================================
        
        // Detect mobile devices
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Handle AR button visibility and errors
        const arButton = document.querySelector('#ar-button');
        
        // Listen for AR status changes with detailed logging
        viewer.addEventListener('ar-status', (event) => {
            const status = event.detail.status;
            const mode = event.detail.mode;
            
            console.log('AR status:', status);
            console.log('AR mode:', mode);
            console.log('AR status detail:', event.detail);
            
            if (status === 'failed') {
                console.error('=== AR INITIALIZATION FAILED ===');
                console.log('Failed AR mode:', mode);
                console.log('AR modes configured:', viewer.arModes);
                console.log('AR available:', viewer.arAvailable);
                console.log('AR supported:', viewer.arSupported);
                console.log('Model loaded:', viewer.loaded);
                console.log('Model source:', viewer.src);
                console.log('iOS source:', viewer.iosSrc);
                console.log('User agent:', navigator.userAgent);
                console.log('Is HTTPS:', location.protocol === 'https:');
                
                // Check for common issues
                if (!viewer.loaded) {
                    console.error('❌ Model not loaded - AR cannot initialize');
                }
                if (!viewer.arSupported) {
                    console.error('❌ AR not supported on this device/browser');
                }
                if (viewer.arModes && viewer.arModes.length === 0) {
                    console.error('❌ No AR modes available');
                }
                if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                    console.error('❌ AR requires HTTPS (except localhost)');
                }
                if (mode === 'quick-look' && !viewer.iosSrc) {
                    console.warn('⚠️ Quick Look requires USDZ file for iOS');
                }
                if (mode === 'scene-viewer') {
                    console.log('Scene Viewer failed - checking Android compatibility');
                    console.log('Android version check:', /Android/.test(navigator.userAgent));
                }
                console.log('=== END AR FAILURE DIAGNOSTICS ===');
            } else if (status === 'not-presenting') {
                console.log('AR available but not active');
            } else if (status === 'presenting') {
                console.log('AR is active!');
            }
        });
        
        // Catch AR launch errors (like the Intent URL error on desktop)
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('intent://')) {
                console.warn('AR Intent URL not supported on this device');
                if (!isMobileDevice()) {
                    console.info('AR is only available on mobile devices. Please open this page on your phone or tablet.');
                }
            }
        });
        
        // Check AR availability after model loads
        viewer.addEventListener('load', () => {
            console.log('Model loaded, checking AR availability...');
            console.log('AR available:', viewer.arAvailable);
            console.log('AR supported:', viewer.arSupported);
            console.log('AR modes:', viewer.arModes);
            console.log('Model loaded:', viewer.loaded);
            console.log('Model source:', viewer.src);
            console.log('iOS source:', viewer.iosSrc);
            
            setTimeout(() => {
                if (!viewer.arAvailable && !isMobileDevice()) {
                    arButton.style.display = 'none';
                }
                
                // Log AR capabilities
                if (isMobileDevice()) {
                    console.log('Mobile device detected');
                    console.log('AR available:', viewer.arAvailable);
                    console.log('AR supported:', viewer.arSupported);
                    
                    if (!viewer.arAvailable) {
                        console.warn('AR not available on this mobile device');
                        console.log('Possible reasons:');
                        console.log('1. Browser does not support AR');
                        console.log('2. Model file too large');
                        console.log('3. Missing USDZ file (for iOS)');
                        console.log('4. Camera permissions not granted');
                        console.log('5. Device does not support AR');
                    }
                }
            }, 1000);
        });

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentStepIndex = -1; // Starts before the first step
        let isAnimating = false;

        // ============================================
        // EVENT HANDLERS
        // ============================================

        // ============================================
        // DEBUG: Log non-click events (click events handled separately)
        // ============================================
        const eventsToLog = ['ar-status', 'load', 'model-load', 'error', 'scene-graph-ready'];
        eventsToLog.forEach(eventType => {
            viewer.addEventListener(eventType, (e) => {
                console.log(`[${eventType}] event fired`);
                if (e.detail && typeof e.detail === 'object') {
                    console.log(`[${eventType}] event.detail:`, e.detail);
                }
            });
        });

        // OBJECT-SPECIFIC CLICK HANDLER USING RAYCASTING
        viewer.addEventListener('click', (event) => {
            // Ignore if animating (unless it's a looping step)
            if (isAnimating && !CONFIG.steps[currentStepIndex]?.loop) return;
            
            // Ignore AR button clicks
            if (event.target.id === 'ar-button') return;
            
            // Use raycasting to find hit node
            let nodeName = null;
            if (raycaster && hierarchyNodes.length > 0) {
                nodeName = findHitNode(event.clientX, event.clientY);
            }
            
            // Log the node name for debugging (preserve the name)
            if (nodeName) {
                console.log('Hit node:', nodeName);
            }
            
            if (!nodeName) {
                // Clicked on empty space - show feedback
                if (currentStepIndex >= 0 && currentStepIndex < CONFIG.steps.length) {
                    const stepData = CONFIG.steps[currentStepIndex];
                    descText.innerText = stepData.objectHint || CONFIG.continuePrompt;
                }
                return;
            }
            
            // Find which step this node belongs to
            const objectStepIndex = getStepIndexForNode(nodeName);
            
            if (objectStepIndex === -1) {
                // Clicked node is not interactive
                if (currentStepIndex >= 0 && currentStepIndex < CONFIG.steps.length) {
                    const stepData = CONFIG.steps[currentStepIndex];
                    descText.innerText = stepData.objectHint || CONFIG.continuePrompt;
                }
                return;
            }
            
            // Check if this is the correct step to advance
            const expectedStepIndex = currentStepIndex + 1;
            
            if (objectStepIndex === expectedStepIndex) {
                // Correct object clicked - advance!
                playNextStep();
            } else if (objectStepIndex < expectedStepIndex) {
                // Clicked an object from a previous step
                descText.innerText = 'This step has already been completed. ' + (CONFIG.steps[expectedStepIndex]?.objectHint || '');
            } else {
                // Clicked an object from a future step
                descText.innerText = 'Complete previous steps first. ' + (CONFIG.steps[expectedStepIndex]?.objectHint || '');
            }
        });


        // ============================================
        // PLAYBACK FUNCTIONS
        // ============================================

        function playNextStep() {
            currentStepIndex++;
            const stepData = CONFIG.steps[currentStepIndex];

            // Update UI
            titleText.innerText = stepData.title;
            descText.innerText = stepData.desc;
            isAnimating = true;

            // Play the keyframe range
            playKeyframeRange(stepData);
        }

        function resetExperience() {
            currentStepIndex = -1;
            titleText.innerText = CONFIG.resetTitle;
            descText.innerText = CONFIG.resetDesc;
            
            // Reset to first frame
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            isAnimating = false;
        }

        // ============================================
        // ERROR HANDLING
        // ============================================
        
        viewer.addEventListener('error', (event) => {
            console.error('Model loading error:', event.detail);
            titleText.innerText = 'Error';
            descText.innerText = 'Failed to load 3D model. Check console for details.';
        });

        viewer.addEventListener('load', () => {
            console.log('Model loaded successfully');
        });

        // ============================================
        // HELPER: Debug object names
        // ============================================

        // Uncomment to debug object names:
        // viewer.addEventListener('load', () => {
        //     const scene = viewer.getScene();
        //     console.log('=== All Objects in Model ===');
        //     scene.traverse((object) => {
        //         if (object.isMesh) {
        //             console.log(`Name: "${object.name}", Type: ${object.type}`);
        //         }
        //     });
        // });

    </script>
</body>
</html>
