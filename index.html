<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tap-to-Advance AR Experience</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    
    <style>
        /* --- CSS STYLING --- */
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Helvetica', 'Arial', sans-serif; 
            overflow: hidden; 
        }
        
        /* The AR Window */
        model-viewer {
            width: 100vw;
            height: 100vh;
            background-color: #f5f5f5; /* Fallback color */
            --poster-color: #f5f5f5;
        }

        /* The UI Overlay Container */
        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Let taps pass through to the 3D model */
            z-index: 100;
        }

        /* The Branding / Instruction Card */
        .card {
            display: inline-block;
            background: white;
            padding: 16px 24px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .card h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card p {
            margin: 4px 0 0 0;
            font-size: 14px;
            color: #555;
        }

        /* Hide UI while loading */
        model-viewer:not([loaded]) #ui-layer { 
            opacity: 0; 
        }

        /* Custom AR Button Styling */
        #ar-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 200;
            cursor: pointer;
            transition: background 0.2s;
        }

        #ar-button:hover {
            background: #0056CC;
        }
    </style>
</head>
<body>

    <model-viewer 
        id="ar-viewer"
        src="assets/Dalgona-OneTake_0001.glb"
        ios-src="assets/model.usdz"
        ar
        ar-modes="webxr scene-viewer quick-look"
        camera-controls
        disable-zoom
        disable-tap
        shadow-intensity="1.2"
        environment-image="neutral" 
        tone-mapping="commerce"
        animation-name="animation_0"
        autoplay="false">
        
        <button slot="ar-button" id="ar-button">
            View in your space
        </button>
    </model-viewer>

    <div id="ui-layer">
        <div class="card" id="info-card">
            <h2 id="step-title">Welcome</h2>
            <p id="step-desc">Tap the Nescafé sachet to start!</p>
        </div>
    </div>

    <script type="module">
        // ============================================
        // ON-SCREEN CONSOLE FOR MOBILE DEBUGGING
        // ============================================
        
        function createOnScreenConsole() {
            const consoleDiv = document.createElement('div');
            consoleDiv.id = 'mobile-console';
            consoleDiv.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 200px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.95);
                color: #0f0;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 8px;
                z-index: 10000;
                display: none;
                border-top: 2px solid #0f0;
                box-shadow: 0 -2px 10px rgba(0, 255, 0, 0.3);
            `;
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '✕';
            closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: #f00;
                color: white;
                border: none;
                border-radius: 3px;
                width: 24px;
                height: 24px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                z-index: 10001;
            `;
            closeBtn.onclick = () => {
                consoleDiv.style.display = 'none';
            };
            consoleDiv.appendChild(closeBtn);
            
            // Add clear button
            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 35px;
                background: #333;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 8px;
                cursor: pointer;
                font-size: 10px;
                z-index: 10001;
            `;
            clearBtn.onclick = () => {
                const logs = consoleDiv.querySelectorAll('div:not(button)');
                logs.forEach(log => log.remove());
            };
            consoleDiv.appendChild(clearBtn);
            
            document.body.appendChild(consoleDiv);
            
            // Store original console methods
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;
            
            function addToScreen(type, ...args) {
                const consoleDiv = document.getElementById('mobile-console');
                if (!consoleDiv) return;
                
                const message = args.map(arg => {
                    if (arg === null) return 'null';
                    if (arg === undefined) return 'undefined';
                    if (typeof arg === 'object') {
                        try {
                            return JSON.stringify(arg, null, 2);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return String(arg);
                }).join(' ');
                
                const logEntry = document.createElement('div');
                logEntry.style.cssText = `
                    padding: 3px 0;
                    border-bottom: 1px solid #222;
                    word-wrap: break-word;
                    color: ${type === 'error' ? '#ff4444' : type === 'warn' ? '#ffaa00' : type === 'info' ? '#00aaff' : '#00ff00'};
                    white-space: pre-wrap;
                `;
                
                const timestamp = new Date().toLocaleTimeString();
                logEntry.textContent = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
                consoleDiv.appendChild(logEntry);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                
                // Auto-show console for errors and warnings
                if (type === 'error' || type === 'warn') {
                    consoleDiv.style.display = 'block';
                }
            }
            
            // Override console methods
            console.log = function(...args) {
                originalLog.apply(console, args);
                addToScreen('log', ...args);
            };
            
            console.error = function(...args) {
                originalError.apply(console, args);
                addToScreen('error', ...args);
            };
            
            console.warn = function(...args) {
                originalWarn.apply(console, args);
                addToScreen('warn', ...args);
            };
            
            console.info = function(...args) {
                if (originalInfo) originalInfo.apply(console, args);
                addToScreen('info', ...args);
            };
            
            // Toggle console with triple tap
            let tapCount = 0;
            let tapTimer = null;
            document.addEventListener('touchstart', (e) => {
                // Don't trigger on UI elements
                if (e.target.tagName === 'BUTTON' || e.target.closest('#ui-layer')) {
                    return;
                }
                
                tapCount++;
                clearTimeout(tapTimer);
                tapTimer = setTimeout(() => {
                    if (tapCount === 3) {
                        const consoleDiv = document.getElementById('mobile-console');
                        if (consoleDiv) {
                            consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                        }
                    }
                    tapCount = 0;
                }, 400);
            });
            
            // Also allow keyboard toggle (for desktop testing)
            document.addEventListener('keydown', (e) => {
                if (e.key === '`' && e.ctrlKey) {
                    e.preventDefault();
                    const consoleDiv = document.getElementById('mobile-console');
                    if (consoleDiv) {
                        consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                    }
                }
            });
            
            console.log('On-screen console initialized. Triple-tap to toggle, or press Ctrl+`');
        }
        
        // Initialize console immediately
        createOnScreenConsole();
        
        // ============================================
        // CONFIGURATION: Keyframe-based animation with object-specific taps
        // ============================================
        
        const CONFIG = {
            // Path to your 3D model (GLB format)
            modelPath: 'assets/Dalgona-OneTake_0001.glb',
            
            // Path to iOS USDZ format (optional, for better iOS support)
            iosModelPath: 'assets/model.usdz',
            
            // Animation name (single track)
            animationName: 'animation_0',
            
            // Frame rate of your animation
            fps: 30,
            
            // Keyframe spans for each step
            steps: [
                { 
                    startFrame: 1,
                    endFrame: 80,
                    title: 'Step 1: The Mix', 
                    desc: 'Nescafé + Water into bowl',
                    objectHint: 'Tap the Nescafé sachet, pot, or handle'
                },
                { 
                    startFrame: 80,
                    endFrame: 140,
                    title: 'Step 2: Whip It', 
                    desc: 'Whisking into foam...',
                    objectHint: 'Tap the whisk'
                },
                { 
                    startFrame: 140,
                    endFrame: 200,
                    title: 'Step 3: The Base', 
                    desc: 'Milk into mug...',
                    objectHint: 'Tap the jug'
                },
                { 
                    startFrame: 200,
                    endFrame: 240,
                    title: 'Step 4: Transfer', 
                    desc: 'Bowl into mug...',
                    objectHint: 'Tap the mixing bowl'
                },
                { 
                    startFrame: 240,
                    endFrame: 300,
                    title: 'Step 5: Final Touch', 
                    desc: 'Add ice...',
                    objectHint: 'Tap the scoop or ice bowl',
                    loop: false
                }
            ],
            
            // Object names that trigger each step (will be matched flexibly against GLB node names)
            // Note: Matching is flexible - handles dots/underscores, spaces/underscores, case variations
            interactiveObjects: [
                ['NescafeBTM', 'NescafeTOP_(Copy)', 'NescafeTOP', 'teapot', 'pot', 'handle'],  // Step 1
                ['whisk'],                                                // Step 2
                ['jug'],                                                  // Step 3
                ['mixingbowl', 'mixing.bowl'],                            // Step 4
                ['scoop', 'icebowl', 'ice.bowl']                          // Step 5
            ],
            
            // Welcome message
            welcomeTitle: 'Welcome',
            welcomeDesc: 'Tap the Nescafé sachet to start!',
            
            // Continue prompt
            continuePrompt: 'Tap the correct object to continue ->',
            
            // Reset message
            resetTitle: 'Replay?',
            resetDesc: 'Tap to start again.',
            
            // Visual feedback for interactive objects
            enableHoverFeedback: true
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        
        const viewer = document.querySelector('#ar-viewer');
        const titleText = document.querySelector('#step-title');
        const descText = document.querySelector('#step-desc');
        const card = document.querySelector('#info-card');

        // Set model paths from config
        viewer.src = CONFIG.modelPath;
        if (CONFIG.iosModelPath) {
            viewer.setAttribute('ios-src', CONFIG.iosModelPath);
        }
        viewer.animationName = CONFIG.animationName;
        viewer.autoplay = false;
        viewer.loop = false;

        // Set welcome message
        titleText.innerText = CONFIG.welcomeTitle;
        descText.innerText = CONFIG.welcomeDesc;

        // ============================================
        // MODEL-VIEWER CLICK EVENT SETUP
        // ============================================
        
        // Map of node names to step indices (with flexible matching)
        let nodeToStepMap = new Map();
        let hierarchyNodes = []; // Store hierarchy nodes with meshes
        let THREE = null; // Will store Three.js reference
        let raycaster = null;
        let scene = null; // Store the Three.js scene
        let camera = null; // Store the camera reference
        
        // Initialize after model loads
        viewer.addEventListener('load', () => {
            // Set initial time to frame 1
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            
            // Access hierarchy and build mappings
            setupHitDetection();
        });
        
        // Also listen for scene-graph-ready event
        viewer.addEventListener('scene-graph-ready', () => {
            console.log('Scene graph ready');
            setupHitDetection();
        });
        
        function setupHitDetection() {
            // Import Three.js for raycasting
            if (!window.THREE) {
                import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js').then((THREE_Module) => {
                    window.THREE = THREE_Module;
                    THREE = THREE_Module;
                    initializeHitDetection();
                }).catch((err) => {
                    console.error('Failed to import Three.js:', err);
                });
            } else {
                THREE = window.THREE;
                initializeHitDetection();
            }
        }
        
        function initializeHitDetection() {
            if (!THREE) {
                console.error('Three.js not available');
                return;
            }
            
            // Access hierarchy from viewer.model
            const symbols = Object.getOwnPropertySymbols(viewer.model);
            const hierarchySym = symbols.find(s => s.toString().includes('hierarchy'));
            
            if (!hierarchySym) {
                console.error('Could not find hierarchy Symbol');
                return;
            }
            
            const hierarchy = viewer.model[hierarchySym];
            hierarchyNodes = hierarchy.filter(node => node.mesh); // Only nodes with meshes
            
            console.log(`Found ${hierarchyNodes.length} nodes with meshes`);
            
            // Build flexible node-to-step mapping
            buildFlexibleNodeMapping(hierarchyNodes);
            
            // Access the scene from viewer.model
            // Try to find the scene through various Symbol properties
            const sceneSym = symbols.find(s => {
                const symStr = s.toString();
                return symStr.includes('scene') || symStr.includes('roots');
            });
            
            if (sceneSym) {
                const roots = viewer.model[sceneSym];
                if (Array.isArray(roots) && roots.length > 0) {
                    // The first root is usually the scene
                    scene = roots[0];
                    console.log('Found scene through roots Symbol');
                }
            }
            
            // If we didn't find the scene, try accessing it through renderRoot
            if (!scene && viewer.renderRoot) {
                // Try to find Three.js scene in renderRoot
                const findScene = (obj) => {
                    if (!obj) return null;
                    if (obj.type === 'Scene' || (obj.isScene && obj.isScene())) return obj;
                    if (obj.children) {
                        for (let child of obj.children) {
                            const found = findScene(child);
                            if (found) return found;
                        }
                    }
                    return null;
                };
                scene = findScene(viewer.renderRoot);
                if (scene) console.log('Found scene through renderRoot');
            }
            
            // Initialize raycasting
            raycaster = new THREE.Raycaster();
            
            // Try to get camera from viewer's renderer
            // Access through renderRoot or model-viewer's internal renderer
            if (viewer.renderRoot) {
                // Try to find camera in renderRoot
                const findCamera = (obj) => {
                    if (!obj) return null;
                    if (obj.type === 'PerspectiveCamera' || (obj.isPerspectiveCamera && obj.isPerspectiveCamera())) return obj;
                    if (obj.camera) return obj.camera;
                    if (obj.children) {
                        for (let child of obj.children) {
                            const found = findCamera(child);
                            if (found) return found;
                        }
                    }
                    return null;
                };
                camera = findCamera(viewer.renderRoot);
                if (camera) {
                    console.log('Found camera through renderRoot');
                }
            }
            
            // If we still don't have a camera, try accessing through viewer's internal properties
            if (!camera && viewer.model) {
                // Check if there's a camera Symbol
                const cameraSym = symbols.find(s => s.toString().includes('camera'));
                if (cameraSym) {
                    camera = viewer.model[cameraSym];
                    if (camera) console.log('Found camera through Symbol');
                }
            }
            
            // Fallback: create a camera with model-viewer's FOV
            if (!camera) {
                const fov = viewer.getFieldOfView ? viewer.getFieldOfView() : 45;
                camera = new THREE.PerspectiveCamera(
                    fov,
                    viewer.clientWidth / viewer.clientHeight,
                    0.1,
                    1000
                );
                console.log('Created fallback camera');
            }
            
            console.log('Hit detection initialized', {
                hasScene: !!scene,
                hasCamera: !!camera,
                nodeCount: hierarchyNodes.length
            });
        }
        
        function buildFlexibleNodeMapping(nodes) {
            // Normalize function to handle variations
            function normalizeName(name) {
                if (!name) return '';
                return name
                    .toLowerCase()
                    .replace(/[._\s-]/g, '') // Remove dots, underscores, spaces, hyphens
                    .trim();
            }
            
            // Build map with normalized names
            CONFIG.interactiveObjects.forEach((targetNames, stepIndex) => {
                const names = Array.isArray(targetNames) ? targetNames : [targetNames];
                names.forEach(configName => {
                    const normalized = normalizeName(configName);
                    nodeToStepMap.set(normalized, stepIndex);
                    
                    // Also check actual node names and create mappings
                    nodes.forEach(node => {
                        const nodeNormalized = normalizeName(node.name);
                        if (nodeNormalized === normalized || 
                            nodeNormalized.includes(normalized) || 
                            normalized.includes(nodeNormalized)) {
                            // Map both the config name and actual node name
                            nodeToStepMap.set(node.name, stepIndex);
                            nodeToStepMap.set(normalized, stepIndex);
                            console.log(`Mapped "${node.name}" -> Step ${stepIndex + 1}`);
                        }
                    });
                });
            });
            
            console.log('Flexible node mapping built:', Array.from(nodeToStepMap.entries()));
        }
        
        // Function to find which node was hit using raycasting
        function findHitNode(clientX, clientY) {
            if (!raycaster || !camera || !hierarchyNodes.length) {
                console.warn('Raycasting prerequisites not met:', {
                    hasRaycaster: !!raycaster,
                    hasCamera: !!camera,
                    hasNodes: hierarchyNodes.length > 0
                });
                return null;
            }
            
            // Get normalized device coordinates (NDC)
            const rect = viewer.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            console.log('Raycasting with coordinates:', {
                clientX, clientY,
                rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },
                mouseNDC: { x: mouse.x, y: mouse.y }
            });
            
            // Update camera properties from model-viewer's camera if available
            // Try to sync camera from viewer's internal state
            if (viewer.getCameraOrbit) {
                const orbit = viewer.getCameraOrbit();
                const target = viewer.getCameraTarget();
                const fov = viewer.getFieldOfView ? viewer.getFieldOfView() : 45;
                
                // Update camera FOV
                camera.fov = fov;
                camera.aspect = rect.width / rect.height;
                camera.updateProjectionMatrix();
                
                // Calculate camera position from orbit
                const radius = orbit.radius || 1;
                const theta = orbit.theta || 0; // azimuth
                const phi = orbit.phi || Math.PI / 2; // polar angle
                
                // Convert spherical to cartesian
                const x = radius * Math.sin(phi) * Math.sin(theta);
                const y = radius * Math.cos(phi);
                const z = radius * Math.sin(phi) * Math.cos(theta);
                
                camera.position.set(
                    target.x + x,
                    target.y + y,
                    target.z + z
                );
                camera.lookAt(target.x, target.y, target.z);
                camera.updateMatrixWorld();
                
                console.log('Camera synced:', {
                    position: camera.position,
                    target: target,
                    fov: fov,
                    orbit: orbit
                });
            }
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Collect all meshes from hierarchy nodes
            const meshes = [];
            hierarchyNodes.forEach(node => {
                if (node.mesh) {
                    if (node.mesh.isMesh) {
                        meshes.push(node.mesh);
                    } else if (node.mesh.children) {
                        // If mesh has children, traverse them
                        node.mesh.traverse((child) => {
                            if (child.isMesh) {
                                meshes.push(child);
                            }
                        });
                    }
                }
            });
            
            console.log(`Raycasting against ${meshes.length} meshes`);
            
            if (meshes.length === 0) {
                console.warn('No meshes found for raycasting');
                return null;
            }
            
            // Perform raycasting
            const intersects = raycaster.intersectObjects(meshes, true);
            
            console.log(`Found ${intersects.length} intersections`);
            
            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                console.log('Hit mesh:', hitMesh.name || 'unnamed', hitMesh);
                
                // Find which node this mesh belongs to
                // Check direct mesh match first
                let hitNode = hierarchyNodes.find(node => node.mesh === hitMesh);
                
                // If not found, check if mesh is a child of any node's mesh
                if (!hitNode) {
                    hitNode = hierarchyNodes.find(node => {
                        if (!node.mesh) return false;
                        let found = false;
                        node.mesh.traverse((child) => {
                            if (child === hitMesh) found = true;
                        });
                        return found;
                    });
                }
                
                // Also check by mesh name
                if (!hitNode && hitMesh.name) {
                    hitNode = hierarchyNodes.find(node => {
                        if (!node.mesh) return false;
                        let found = false;
                        node.mesh.traverse((child) => {
                            if (child.name === hitMesh.name) found = true;
                        });
                        return found;
                    });
                }
                
                if (hitNode) {
                    console.log('✓ Hit node:', hitNode.name);
                    return hitNode.name;
                } else {
                    console.warn('Hit mesh but could not find corresponding node');
                }
            } else {
                console.log('No intersections found');
            }
            
            return null;
        }


        // ============================================
        // KEYFRAME-BASED PLAYBACK FUNCTIONS
        // ============================================

        // Convert frame number to time in seconds
        function frameToTime(frame, fps = CONFIG.fps) {
            return frame / fps;
        }

        // Play a specific keyframe range
        function playKeyframeRange(stepData) {
            const startTime = frameToTime(stepData.startFrame);
            const endTime = frameToTime(stepData.endFrame);
            
            // Set the start time
            viewer.currentTime = startTime;
            
            // Play the animation
            viewer.play();
            viewer.loop = stepData.loop || false;
            
            // Monitor playback using requestAnimationFrame for smooth control
            function checkPlayback() {
                if (!isAnimating) return; // Stop if user advanced
                
                if (viewer.currentTime >= endTime) {
                    viewer.pause();
                    isAnimating = false;
                    
                    if (stepData.loop) {
                        // Restart this range
                        viewer.currentTime = startTime;
                        viewer.play();
                        requestAnimationFrame(checkPlayback);
                    } else {
                        // Finished
                        if (currentStepIndex < CONFIG.steps.length - 1) {
                            descText.innerText = CONFIG.continuePrompt;
                        }
                    }
                } else {
                    requestAnimationFrame(checkPlayback);
                }
            }
            
            requestAnimationFrame(checkPlayback);
        }

        // ============================================
        // OBJECT-SPECIFIC CLICK DETECTION USING MODEL-VIEWER'S CLICK EVENT
        // ============================================

        function getStepIndexForNode(nodeName) {
            if (!nodeName) return -1;
            
            // Try exact match first
            let stepIndex = nodeToStepMap.get(nodeName);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try flexible matching (normalize the name)
            function normalizeName(name) {
                return name.toLowerCase().replace(/[._\s-]/g, '').trim();
            }
            
            const normalized = normalizeName(nodeName);
            stepIndex = nodeToStepMap.get(normalized);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try partial matching
            for (const [mappedName, mappedStep] of nodeToStepMap.entries()) {
                const mappedNormalized = normalizeName(mappedName);
                if (normalized === mappedNormalized || 
                    normalized.includes(mappedNormalized) || 
                    mappedNormalized.includes(normalized)) {
                    return mappedStep;
                }
            }
            
            return -1;
        }

        // ============================================
        // AR AVAILABILITY CHECK & DESKTOP HANDLING
        // ============================================
        
        // Detect mobile devices
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Handle AR button visibility and errors
        const arButton = document.querySelector('#ar-button');
        
        // Listen for AR status changes
        viewer.addEventListener('ar-status', (event) => {
            console.log('AR status:', event.detail.status);
        });
        
        // Catch AR launch errors (like the Intent URL error on desktop)
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('intent://')) {
                console.warn('AR Intent URL not supported on this device');
                if (!isMobileDevice()) {
                    console.info('AR is only available on mobile devices. Please open this page on your phone or tablet.');
                }
            }
        });
        
        // Check AR availability after model loads
        viewer.addEventListener('load', () => {
            setTimeout(() => {
                if (!viewer.arAvailable && !isMobileDevice()) {
                    arButton.style.display = 'none';
                }
            }, 1000);
        });

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentStepIndex = -1; // Starts before the first step
        let isAnimating = false;

        // ============================================
        // EVENT HANDLERS
        // ============================================

        // ============================================
        // DEBUG: Log all events model-viewer fires
        // ============================================
        const eventsToLog = ['click', 'select', 'ar-status', 'load', 'model-load', 'error', 'scene-graph-ready'];
        eventsToLog.forEach(eventType => {
            viewer.addEventListener(eventType, (e) => {
                console.log(`[${eventType}] event fired`);
                console.log(`[${eventType}] event object:`, e);
                console.log(`[${eventType}] event.detail:`, e.detail);
                console.log(`[${eventType}] event.target:`, e.target);
                if (e.detail && typeof e.detail === 'object') {
                    console.log(`[${eventType}] event.detail keys:`, Object.keys(e.detail));
                }
            });
        });

        // OBJECT-SPECIFIC CLICK HANDLER USING MODEL-VIEWER'S CLICK EVENT
        viewer.addEventListener('click', (event) => {
            // Ignore if animating (unless it's a looping step)
            if (isAnimating && !CONFIG.steps[currentStepIndex]?.loop) return;
            
            // Ignore AR button clicks
            if (event.target.id === 'ar-button') return;
            
            // Log the ENTIRE event object to see what's available
            console.log('=== CLICK EVENT DEBUG ===');
            console.log('Full event object:', event);
            console.log('event.type:', event.type);
            console.log('event.detail:', event.detail);
            console.log('event.detail type:', typeof event.detail);
            console.log('event.target:', event.target);
            console.log('event.target.id:', event.target?.id);
            console.log('event.target.tagName:', event.target?.tagName);
            console.log('All event properties:', Object.keys(event));
            
            // Try accessing hit information from various possible locations
            let nodeName = null;
            
            // Method 1: Check event.detail (but it's showing as 1, so might not be here)
            if (event.detail && typeof event.detail === 'object') {
                console.log('event.detail is an object, checking properties...');
                console.log('event.detail.hit:', event.detail.hit);
                console.log('event.detail.node:', event.detail.node);
                console.log('event.detail.material:', event.detail.material);
                
                nodeName = event.detail.hit?.node?.name || 
                           event.detail.node?.name || 
                           event.detail.nodeName ||
                           event.detail.name ||
                           event.detail.hit?.name;
            }
            
            // Method 2: Check if model-viewer has a queryHit method
            if (!nodeName && typeof viewer.queryHit === 'function') {
                console.log('Trying viewer.queryHit...');
                try {
                    const hit = viewer.queryHit(event.clientX, event.clientY);
                    console.log('queryHit result:', hit);
                    if (hit) {
                        nodeName = hit.node?.name || hit.nodeName || hit.name;
                    }
                } catch (e) {
                    console.log('queryHit error:', e);
                }
            }
            
            // Method 3: Check event.target for model-viewer specific properties
            if (!nodeName && event.target) {
                console.log('Checking event.target properties...');
                console.log('event.target properties:', Object.keys(event.target));
                if (event.target.modelViewer) {
                    const mv = event.target.modelViewer;
                    console.log('modelViewer properties:', Object.keys(mv));
                }
            }
            
            // Method 4: Check if there's hit information in the event's coordinates
            if (!nodeName) {
                console.log('Checking for hit info via coordinates...');
                console.log('event.clientX:', event.clientX);
                console.log('event.clientY:', event.clientY);
                // Try to see if model-viewer exposes a way to query hits
            }
            
            // Method 5: Access Symbol properties to get node hierarchy
            if (!nodeName && viewer.model) {
                console.log('Checking viewer.model Symbol properties...');
                const symbols = Object.getOwnPropertySymbols(viewer.model);
                console.log('Found', symbols.length, 'Symbol properties');
                
                // Find and access hierarchy Symbol
                const hierarchySym = symbols.find(s => s.toString().includes('hierarchy'));
                if (hierarchySym) {
                    try {
                        const hierarchy = viewer.model[hierarchySym];
                        console.log('Hierarchy accessed:', Array.isArray(hierarchy) ? `Array(${hierarchy.length})` : typeof hierarchy);
                        
                        if (Array.isArray(hierarchy)) {
                            console.log('Hierarchy contains', hierarchy.length, 'nodes');
                            
                            // Log first few nodes to see structure
                            hierarchy.slice(0, 10).forEach((node, index) => {
                                console.log(`Node ${index}:`, {
                                    name: node?.name,
                                    type: node?.type,
                                    keys: Object.keys(node || {})
                                });
                            });
                            
                            // Store hierarchy for potential use
                            window.modelHierarchy = hierarchy;
                        }
                    } catch (e) {
                        console.error('Error accessing hierarchy:', e);
                    }
                }
                
                // Check for primitives Symbol (might contain mesh info)
                const primitivesSym = symbols.find(s => s.toString().includes('primitives'));
                if (primitivesSym) {
                    try {
                        const primitives = viewer.model[primitivesSym];
                        console.log('Primitives:', Array.isArray(primitives) ? `Array(${primitives.length})` : typeof primitives);
                    } catch (e) {
                        console.error('Error accessing primitives:', e);
                    }
                }
            }
            
            // Method 6: Use raycasting with hierarchy nodes
            if (!nodeName && raycaster && hierarchyNodes.length > 0) {
                console.log('Attempting raycasting with hierarchy nodes...');
                nodeName = findHitNode(event.clientX, event.clientY);
                if (nodeName) {
                    console.log('✓ Found node via raycasting:', nodeName);
                }
            }
            
            console.log('Final resolved node name:', nodeName);
            console.log('=== END CLICK DEBUG ===');
            
            if (!nodeName) {
                // Clicked on empty space - show feedback
                if (currentStepIndex >= 0 && currentStepIndex < CONFIG.steps.length) {
                    const stepData = CONFIG.steps[currentStepIndex];
                    descText.innerText = stepData.objectHint || CONFIG.continuePrompt;
                }
                console.warn('No node name detected. Check console for event structure.');
                return;
            }
            
            // Find which step this node belongs to
            const objectStepIndex = getStepIndexForNode(nodeName);
            
            if (objectStepIndex === -1) {
                // Clicked node is not interactive
                console.log('Clicked node is not interactive:', nodeName);
                if (currentStepIndex >= 0 && currentStepIndex < CONFIG.steps.length) {
                    const stepData = CONFIG.steps[currentStepIndex];
                    descText.innerText = stepData.objectHint || CONFIG.continuePrompt;
                }
                return;
            }
            
            // Check if this is the correct step to advance
            const expectedStepIndex = currentStepIndex + 1;
            
            if (objectStepIndex === expectedStepIndex) {
                // Correct object clicked - advance!
                playNextStep();
            } else if (objectStepIndex < expectedStepIndex) {
                // Clicked an object from a previous step
                descText.innerText = 'This step has already been completed. ' + (CONFIG.steps[expectedStepIndex]?.objectHint || '');
            } else {
                // Clicked an object from a future step
                descText.innerText = 'Complete previous steps first. ' + (CONFIG.steps[expectedStepIndex]?.objectHint || '');
            }
        });

        // Also try listening to 'select' event if model-viewer provides it
        viewer.addEventListener('select', (event) => {
            console.log('=== SELECT EVENT DEBUG ===');
            console.log('Select event fired:', event);
            console.log('Select event detail:', event.detail);
            console.log('Select event target:', event.target);
            console.log('=== END SELECT DEBUG ===');
        });

        // ============================================
        // PLAYBACK FUNCTIONS
        // ============================================

        function playNextStep() {
            currentStepIndex++;
            const stepData = CONFIG.steps[currentStepIndex];

            // Update UI
            titleText.innerText = stepData.title;
            descText.innerText = stepData.desc;
            isAnimating = true;

            // Play the keyframe range
            playKeyframeRange(stepData);
        }

        function resetExperience() {
            currentStepIndex = -1;
            titleText.innerText = CONFIG.resetTitle;
            descText.innerText = CONFIG.resetDesc;
            
            // Reset to first frame
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            isAnimating = false;
        }

        // ============================================
        // ERROR HANDLING
        // ============================================
        
        viewer.addEventListener('error', (event) => {
            console.error('Model loading error:', event.detail);
            titleText.innerText = 'Error';
            descText.innerText = 'Failed to load 3D model. Check console for details.';
        });

        viewer.addEventListener('load', () => {
            console.log('Model loaded successfully');
        });

        // ============================================
        // HELPER: Debug object names
        // ============================================

        // Uncomment to debug object names:
        // viewer.addEventListener('load', () => {
        //     const scene = viewer.getScene();
        //     console.log('=== All Objects in Model ===');
        //     scene.traverse((object) => {
        //         if (object.isMesh) {
        //             console.log(`Name: "${object.name}", Type: ${object.type}`);
        //         }
        //     });
        // });

    </script>
</body>
</html>
