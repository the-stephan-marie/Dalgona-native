<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tap-to-Advance AR Experience</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    
    <style>
        /* --- CSS STYLING --- */
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Helvetica', 'Arial', sans-serif; 
            overflow: hidden;
            background-image: url('assets/bg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }
        
        /* Header Section - Completely Transparent */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: transparent;
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            box-sizing: border-box;
        }
        
        #logo {
            max-width: 85%;
            width: auto;
            height: auto;
            display: block;
            object-fit: contain;
            margin-bottom: 30px;
        }
        
        /* Recipe Name - Below Header */
        #recipe-name {
            position: fixed;
            top: 80px;
            left: 0;
            right: 0;
            z-index: 200;
            font-family: 'Helvetica', 'Arial', sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
            text-align: center;
            margin: 0;
            line-height: 1.3;
            padding: 30px 20px 0 20px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        /* Mobile Responsive Header */
        @media (max-width: 480px) {
            #header {
                padding: 12px 16px;
            }
            
            #logo {
                max-width: 80%;
                margin-bottom: 25px;
            }
            
            #recipe-name {
                top: 70px;
                font-size: 16px;
                padding: 25px 16px 0 16px;
            }
        }
        
        @media (min-width: 481px) and (max-width: 768px) {
            #logo {
                max-width: 82%;
                margin-bottom: 28px;
            }
            
            #recipe-name {
                top: 75px;
                font-size: 17px;
                padding: 28px 20px 0 20px;
            }
        }
        
        @media (min-width: 769px) {
            #logo {
                margin-bottom: 35px;
            }
            
            #recipe-name {
                top: 90px;
                font-size: 20px;
                padding: 35px 20px 0 20px;
            }
        }
        
        /* The AR Window */
        model-viewer {
            width: 100vw;
            height: 100vh;
            background-color: transparent;
            --poster-color: transparent;
            margin-top: 0;
            position: relative;
        }
        
        /* Adjust model-viewer to account for header */
        #ar-viewer {
            margin-top: 0;
        }

        /* The UI Overlay Container */
        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Let taps pass through to the 3D model */
            z-index: 100;
        }

        /* The Branding / Instruction Card */
        .card {
            display: inline-block;
            background: white;
            padding: 16px 24px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            pointer-events: auto; /* Enable clicks on the card */
            cursor: pointer; /* Show it's clickable */
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.2);
        }

        .card:active {
            transform: translateY(0);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .card h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card p {
            margin: 4px 0 0 0;
            font-size: 14px;
            color: #555;
        }

        /* Hide UI while loading */
        model-viewer:not([loaded]) #ui-layer { 
            opacity: 0; 
        }

        /* Custom AR Button Styling - HIDDEN */
        #ar-button {
            display: none !important;
        }

        /* AR Recipe Link - Bottom Overlay */
        /* OLD - REPLACED WITH ar-recipe-card */
        #ar-recipe-link-old {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007AFF;
            color: white !important;
            border: none;
            padding: 16px 32px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.4);
            z-index: 99999 !important; /* Very high z-index to ensure it's above AR camera feed */
            cursor: pointer;
            transition: all 0.2s;
            display: none; /* Hidden by default, shown only in AR mode */
            pointer-events: auto !important; /* Enable clicks */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            text-decoration: none;
            text-align: center;
            opacity: 1 !important;
            visibility: visible !important;
        }

        #ar-recipe-link-old:hover {
            background: #0056CC;
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 25px rgba(0, 122, 255, 0.5);
        }

        #ar-recipe-link-old:active {
            transform: translateX(-50%) scale(0.95);
        }

        /* Show link when AR is active - CSS-based for immediate visibility */
        /* AR Recipe Card - WebXR DOM Overlay (projects onto camera feed) */
        /* Hide the card by default (so it doesn't show on the 3D viewer) */
        /* AR Recipe Card - Hidden by default */
        #ar-recipe-card {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            background: white;
            padding: 16px 20px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom));
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 99999;
            pointer-events: auto;
        }

        /* Show when WebXR AR session is active (session-started, object-placed, or presenting) */
        model-viewer[ar-status="session-started"] #ar-recipe-card,
        model-viewer[ar-status="object-placed"] #ar-recipe-card,
        model-viewer[ar-status="presenting"] #ar-recipe-card {
            display: flex;
        }

        /* Show AR recipe card in 3D viewer mode when AR is not available (after step 6) */
        #ar-recipe-card.show-in-viewer {
            display: flex;
            z-index: 101; /* Above welcome card (z-index: 100) */
        }

        .ar-recipe-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-width: calc(100% - 120px);
        }

        .ar-recipe-description {
            font-size: 14px;
            color: #333;
            margin: 0;
            line-height: 1.4;
        }

        .ar-recipe-url {
            font-size: 12px;
            color: #666;
            margin: 0;
            text-decoration: none;
        }

        .ar-recipe-button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .ar-recipe-button:hover {
            background: #0056CC;
        }

        .ar-recipe-button:active {
            background: #004499;
        }

    </style>
</head>
<body>

    <!-- Header Section -->
    <header id="header">
        <img id="logo" src="assets/NESCAFÃ‰-NEW-PACKAGING_logo_white 4.png" alt="NESCAFÃ‰ Logo">
    </header>
    
    <!-- Recipe Name - Below Header -->
    <h1 id="recipe-name">NESCAFÃ‰Â® 3in1 in Dalgona Coffee Recipe</h1>

    <model-viewer 
        id="ar-viewer"
        src="assets/Dalgona-OneTake_0004.glb"
        ar
        ar-modes="webxr scene-viewer quick-look"
        link="https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona"
        title="Discover 30 days of Nescafe recipes this Ramadan."
        camera-controls
        disable-tap
        shadow-intensity="1.2"
        environment-image="assets/bryanston_park_sunrise_1k.hdr" 
        tone-mapping="commerce"
        animation-name="animation_0">
        
        <!-- AR button removed - will be shown in card after step 6 -->
        
        <!-- AR Recipe Card - WebXR DOM Overlay (styled via ar-status) -->
        <div id="ar-recipe-card">
            <div class="ar-recipe-content">
                <p class="ar-recipe-description">Discover 30 days of Nescafe recipes this Ramadan.</p>
                <a href="https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona" 
                   class="ar-recipe-url" 
                   target="_blank" 
                   rel="noopener noreferrer">
                    nescafe.com
                </a>
            </div>
            <a href="https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona" 
               class="ar-recipe-button" 
               target="_blank" 
               rel="noopener noreferrer">
                Visit
            </a>
        </div>
    </model-viewer>

    <div id="ui-layer">
        <div class="card" id="info-card">
            <h2 id="step-title">TAP TO BEGIN</h2>
            <p id="step-desc">Empty your NESCAFÃ‰Â® 3in1 sachet into a bowl.</p>
        </div>
    </div>


    <script type="module">
        // ============================================
        // CONFIGURATION: Keyframe-based animation with object-specific taps
        // ============================================
        
        const CONFIG = {
            // Path to your 3D model (GLB format) - for 3D viewer mode
            modelPath: 'assets/Dalgona-OneTake_0004.glb',
            
            // Path to compressed model for AR mode (smaller file size for better AR performance)
            arModelPath: 'assets/dalgona-compressed.glb',
            
            // Path to iOS USDZ format (for better iOS Quick Look support)
            // USDZ file provides native animation support in Quick Look
            iosModelPath: 'assets/Dalgona-OneTake_0004.usdz',
            
            // iOS Quick Look Banner Configuration
            // See: https://www.variant3d.com/blog/using-banners-in-quicklooks
            iosBanner: {
                callToAction: 'Visit Recipe',
                checkoutTitle: 'NESCAFÃ‰Â® 3in1 in Dalgona Coffee',
                checkoutSubtitle: 'Discover 30 days of Nescafe recipes this Ramadan.',
                canonicalWebPageURL: 'https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona'
            },
            
            // Animation name (single track)
            animationName: 'animation_0',
            
            // Frame rate of your animation
            fps: 30,
            
            // Keyframe spans for each step
            steps: [
                { 
                    startFrame: 0,
                    endFrame: 50,
                    title: 'STEP 1', 
                    desc: 'Add 1 tablespoon of hot water and mix.',
                    objectHint: 'Tap the NescafÃ© sachet, pot, or handle',
                    nextPrompt: 'STEP 2: Add 1 tablespoon of hot water and mix.'
                },
                { 
                    startFrame: 50,
                    endFrame: 140,
                    title: 'STEP 2', 
                    desc: 'Add 1 tablespoon of hot water and mix.',
                    objectHint: 'Tap the whisk',
                    nextPrompt: 'STEP 3: Pour some milk into your cup.'
                },
                { 
                    startFrame: 140,
                    endFrame: 200,
                    title: 'STEP 3', 
                    desc: 'Pour some milk into your cup.',
                    objectHint: 'Tap the jug',
                    nextPrompt: 'STEP 4: Pour the coffee mixture into your cup of milk.'
                },
                { 
                    startFrame: 200,
                    endFrame: 240,
                    title: 'STEP 4', 
                    desc: 'Pour the coffee mixture into your cup of milk.',
                    objectHint: 'Tap the mixing bowl',
                    nextPrompt: 'STEP 5: Add some ice cubes.'
                },
                { 
                    startFrame: 240,
                    endFrame: 300,
                    title: 'STEP 5', 
                    desc: 'Add some ice cubes.',
                    objectHint: 'Tap the scoop or ice bowl',
                    loop: false
                },
                { 
                    startFrame: 300,
                    endFrame: 360,
                    title: 'Enjoy your NESCAFÃ‰Â® 3in1 Dalgona Coffee Cup', 
                    desc: 'Tap to see view it in your space',
                    objectHint: 'Tap to view in AR',
                    loop: false
                }
            ],
            
            // Object names that trigger each step (will be matched flexibly against GLB node names)
            // Note: Matching is flexible - handles dots/underscores, spaces/underscores, case variations
            interactiveObjects: [
                ['NescafeBTM', 'NescafeTOP_(Copy)', 'NescafeTOP', 'teapot', 'pot', 'handle'],  // Step 1
                ['whisk'],                                                // Step 2
                ['jug'],                                                  // Step 3
                ['mixingbowl', 'mixing.bowl'],                            // Step 4
                ['scoop', 'icebowl', 'ice.bowl']                          // Step 5
            ],
            
            // Welcome message
            welcomeTitle: 'TAP TO BEGIN',
            welcomeDesc: 'Empty your NESCAFÃ‰Â® 3in1 sachet into a bowl.',
            
            // Continue prompt
            continuePrompt: 'Tap the correct object to continue ->',
            
            // Reset message
            resetTitle: 'Replay?',
            resetDesc: 'Tap to start again.',
            
            // Visual feedback for interactive objects
            enableHoverFeedback: true
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        
        const viewer = document.querySelector('#ar-viewer');
        const titleText = document.querySelector('#step-title');
        const descText = document.querySelector('#step-desc');
        const card = document.querySelector('#info-card');

        // Set model paths from config
        viewer.src = CONFIG.modelPath;
        // Set iOS source with Quick Look banner parameters
        if (CONFIG.iosModelPath) {
            // Build iOS URL with banner parameters
            // Parameters are appended with # and separated by &
            // See: https://www.variant3d.com/blog/using-banners-in-quicklooks
            // Note: USDZ URL should be absolute for banner parameters to work
            let iosUrl = CONFIG.iosModelPath;
            
            // Convert relative path to absolute URL if needed
            if (!iosUrl.startsWith('http://') && !iosUrl.startsWith('https://')) {
                // Use current origin to create absolute URL
                const baseUrl = window.location.origin;
                const path = iosUrl.startsWith('/') ? iosUrl : `/${iosUrl}`;
                iosUrl = `${baseUrl}${path}`;
            }
            
            if (CONFIG.iosBanner) {
                const banner = CONFIG.iosBanner;
                const params = [];
                
                // Add banner parameters (URL encoded)
                if (banner.callToAction) {
                    params.push(`callToAction=${encodeURIComponent(banner.callToAction)}`);
                }
                if (banner.checkoutTitle) {
                    params.push(`checkoutTitle=${encodeURIComponent(banner.checkoutTitle)}`);
                }
                if (banner.checkoutSubtitle) {
                    params.push(`checkoutSubtitle=${encodeURIComponent(banner.checkoutSubtitle)}`);
                }
                if (banner.canonicalWebPageURL) {
                    params.push(`canonicalWebPageURL=${encodeURIComponent(banner.canonicalWebPageURL)}`);
                }
                if (banner.price) {
                    params.push(`price=${encodeURIComponent(banner.price)}`);
                }
                
                // Append parameters to USDZ URL with #
                if (params.length > 0) {
                    iosUrl = `${iosUrl}#${params.join('&')}`;
                }
                
                
                
            }
            
            viewer.setAttribute('ios-src', iosUrl);
            
            
            
        } else {
            console.log('âš ï¸ No USDZ file specified - iOS will use GLB (may have limitations)');
        }
        viewer.animationName = CONFIG.animationName;
        viewer.autoplay = false;  // Disabled - animations play on user interaction
        viewer.loop = false;

        // Set welcome message
        titleText.innerText = CONFIG.welcomeTitle;
        descText.innerText = CONFIG.welcomeDesc;

        // ============================================
        // MODEL-VIEWER CLICK EVENT SETUP
        // ============================================
        
        // Map of node names to step indices (with flexible matching)
        let nodeToStepMap = new Map();
        let hierarchyNodes = []; // Store hierarchy nodes with meshes
        let THREE = null; // Will store Three.js reference
        let raycaster = null;
        let camera = null;
        
        // Initialize after model loads
        viewer.addEventListener('load', () => {
            // Set initial time to frame 0
            viewer.currentTime = frameToTime(0);
            viewer.pause();
            
            // Access hierarchy and build mappings
            setupHitDetection();
        });
        
        // Also listen for scene-graph-ready event
        viewer.addEventListener('scene-graph-ready', () => {
            
            setupHitDetection();
        });
        
        function setupHitDetection() {
            console.log('Setting up hit detection...', {
                modelLoaded: viewer.loaded,
                hasTHREE: typeof THREE !== 'undefined'
            });
            
            // Wait for model to load
            if (!viewer.loaded) {
                
                viewer.addEventListener('load', () => {
                    
                    setupHitDetection();
                }, { once: true });
                return;
            }
            
            // Import Three.js for raycasting
            if (!window.THREE) {
                
                import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js').then((THREE_Module) => {
                    window.THREE = THREE_Module;
                    THREE = THREE_Module;
                    
                    initializeHitDetection();
                }).catch((err) => {
                    console.error('Failed to import Three.js:', err);
                });
            } else {
                THREE = window.THREE;
                
                initializeHitDetection();
            }
        }
        
        function initializeHitDetection() {
            if (!THREE) {
                console.error('Three.js not available');
                return;
            }
            
            
            
            // Access hierarchy from viewer.model
            const symbols = Object.getOwnPropertySymbols(viewer.model);
            const hierarchySym = symbols.find(s => s.toString().includes('hierarchy'));
            
            if (!hierarchySym) {
                console.error('Could not find hierarchy Symbol');
                console.log('Available symbols:', symbols.map(s => s.toString()));
                return;
            }
            
            const hierarchy = viewer.model[hierarchySym];
            hierarchyNodes = hierarchy.filter(node => node.mesh); // Only nodes with meshes
            
            
            console.log('Node names:', hierarchyNodes.map(n => n.name).filter(Boolean));
            
            // Build flexible node-to-step mapping
            buildFlexibleNodeMapping(hierarchyNodes);
            
            console.log('Node-to-step mapping:', Array.from(nodeToStepMap.entries()));
            
            // Initialize raycasting
            raycaster = new THREE.Raycaster();
            
            // Create camera for raycasting
            // Will be updated on each click to match model-viewer's camera
            camera = new THREE.PerspectiveCamera(
                75,
                viewer.clientWidth / viewer.clientHeight,
                0.1,
                1000
            );
            
            // Store reference to model-viewer's scene for easier access
            // Try to access through renderRoot
            if (viewer.renderRoot) {
                const canvas = viewer.renderRoot.querySelector('canvas');
                if (canvas && canvas.__THREE__) {
                    window.modelViewerScene = canvas.__THREE__.scene;
                    window.modelViewerCamera = canvas.__THREE__.camera;
                    
                } else {
                    
                }
            }
            
            
        }
        
        function buildFlexibleNodeMapping(nodes) {
            // Normalize function to handle variations
            function normalizeName(name) {
                if (!name) return '';
                return name
                    .toLowerCase()
                    .replace(/[._\s-]/g, '') // Remove dots, underscores, spaces, hyphens
                    .trim();
            }
            
            // Build map with normalized names
            CONFIG.interactiveObjects.forEach((targetNames, stepIndex) => {
                const names = Array.isArray(targetNames) ? targetNames : [targetNames];
                names.forEach(configName => {
                    const normalized = normalizeName(configName);
                    nodeToStepMap.set(normalized, stepIndex);
                    
                    // Also check actual node names and create mappings
                    nodes.forEach(node => {
                        const nodeNormalized = normalizeName(node.name);
                        if (nodeNormalized === normalized || 
                            nodeNormalized.includes(normalized) || 
                            normalized.includes(nodeNormalized)) {
                            // Map both the config name and actual node name
                            nodeToStepMap.set(node.name, stepIndex);
                            nodeToStepMap.set(normalized, stepIndex);
                        }
                    });
                });
            });
            
        }
        
        // Function to find which node was hit using raycasting
        function findHitNode(clientX, clientY) {
            if (!raycaster || !camera || !hierarchyNodes.length) {
                console.warn('findHitNode: Missing required components', {
                    hasRaycaster: !!raycaster,
                    hasCamera: !!camera,
                    hierarchyNodesCount: hierarchyNodes.length
                });
                return null;
            }
            
            // Validate input coordinates
            if (typeof clientX !== 'number' || typeof clientY !== 'number' || 
                isNaN(clientX) || isNaN(clientY)) {
                console.error('findHitNode: Invalid coordinates provided', { clientX, clientY });
                return null;
            }
            
            // Get normalized device coordinates
            const rect = viewer.getBoundingClientRect();
            
            // Account for any page scroll offset
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            // Validate coordinates are within bounds
            if (x < 0 || x > rect.width || y < 0 || y > rect.height) {
                console.warn('findHitNode: Coordinates outside viewer bounds', {
                    clientX, clientY,
                    rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },
                    relative: { x, y }
                });
                return null;
            }
            
            // Convert to normalized device coordinates (-1 to +1)
            const mouse = new THREE.Vector2();
            mouse.x = (x / rect.width) * 2 - 1;
            mouse.y = -(y / rect.height) * 2 + 1;
            
            // Debug logging
            console.log('ðŸ” Raycast at:', { 
                clientX, 
                clientY, 
                relative: { x, y },
                normalized: { x: mouse.x, y: mouse.y },
                viewerSize: { width: rect.width, height: rect.height }
            });
            
            // Get only interactive meshes (exclude ground, table, etc.)
            const interactiveMeshes = hierarchyNodes
                .map(node => node.mesh)
                .filter(mesh => {
                    if (!mesh || !mesh.isMesh) return false;
                    // Filter out non-interactive object names (case-insensitive)
                    const name = (mesh.name || '').toLowerCase();
                    const excludeNames = ['plane', 'ground', 'floor', 'table', 'base', 'surface'];
                    return !excludeNames.some(exclude => name === exclude || name.includes(exclude));
                });
            
            if (interactiveMeshes.length === 0) {
                return null;
            }
            
            // Try to sync camera with model-viewer's camera
            let threeCamera = null;
            if (viewer.renderRoot) {
                const renderer = viewer.renderRoot.querySelector('canvas')?.__THREE__;
                if (renderer) {
                    threeCamera = renderer.camera || renderer.scene?.children.find(child => child.isCamera);
                }
            }
            
            // Update camera to match model-viewer's camera
            if (threeCamera) {
                camera.position.copy(threeCamera.position);
                camera.quaternion.copy(threeCamera.quaternion);
                camera.fov = threeCamera.fov;
                camera.aspect = threeCamera.aspect;
                camera.near = threeCamera.near;
                camera.far = threeCamera.far;
                camera.updateProjectionMatrix();
                camera.updateMatrixWorld();
            } else {
                // Fallback: update aspect ratio
                camera.aspect = viewer.clientWidth / viewer.clientHeight;
                camera.updateProjectionMatrix();
            }
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Perform raycasting ONLY on interactive meshes
            const intersects = raycaster.intersectObjects(interactiveMeshes, true);
            
            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                const distance = intersects[0].distance;
                
                console.log('ðŸŽ¯ Raycast hit:', {
                    meshName: hitMesh.name,
                    distance: distance,
                    point: intersects[0].point,
                    totalIntersects: intersects.length,
                    allHits: intersects.map(i => ({ name: i.object.name, distance: i.distance }))
                });
                
                // Find which node this mesh belongs to
                const hitNode = hierarchyNodes.find(node => {
                    if (node.mesh === hitMesh) return true;
                    // Check parent chain
                    let parent = hitMesh.parent;
                    while (parent) {
                        if (node.mesh === parent) return true;
                        parent = parent.parent;
                    }
                    return false;
                });
                
                if (hitNode) {
                    
                    return hitNode.name;
                } else {
                    
                }
            } else {
                
            }
            
            return null;
        }


        // ============================================
        // KEYFRAME-BASED PLAYBACK FUNCTIONS
        // ============================================

        // Convert frame number to time in seconds
        function frameToTime(frame, fps = CONFIG.fps) {
            return frame / fps;
        }

        // Play a specific keyframe range
        function playKeyframeRange(stepData) {
            const startTime = frameToTime(stepData.startFrame);
            const endTime = frameToTime(stepData.endFrame);
            
            // Set the start time
            viewer.currentTime = startTime;
            
            // Play the animation
            viewer.play();
            viewer.loop = stepData.loop || false;
            
            // Monitor playback using requestAnimationFrame for smooth control
            function checkPlayback() {
                if (!isAnimating) return; // Stop if user advanced
                
                if (viewer.currentTime >= endTime) {
                    // Ensure we're exactly on the final frame
                    viewer.currentTime = endTime;
                    viewer.pause();
                    isAnimating = false;
                    
                    if (stepData.loop) {
                        // Restart this range
                        viewer.currentTime = startTime;
                        viewer.play();
                        requestAnimationFrame(checkPlayback);
                    } else {
                        // Finished - stay on final frame
                        if (currentStepIndex < CONFIG.steps.length - 1) {
                            // Show next step's description
                            const nextStep = CONFIG.steps[currentStepIndex + 1];
                            if (nextStep) {
                                titleText.innerText = nextStep.title;
                                descText.innerText = nextStep.desc;
                            }
                            
                            // If step 4 (index 3) just completed, ensure AR capability is determined before step 5
                            if (currentStepIndex === 3) {
                                // AR capability should already be checked, but verify it's set
                                // This ensures we know AR status before step 5 completes
                            }
                        } else {
                            // Last step completed - handle based on AR capability
                            handleStep6Completion();
                        }
                    }
                } else {
                    requestAnimationFrame(checkPlayback);
                }
            }
            
            requestAnimationFrame(checkPlayback);
        }

        // ============================================
        // OBJECT-SPECIFIC CLICK DETECTION USING MODEL-VIEWER'S CLICK EVENT
        // ============================================

        function getStepIndexForNode(nodeName) {
            if (!nodeName) return -1;
            
            // Try exact match first
            let stepIndex = nodeToStepMap.get(nodeName);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try flexible matching (normalize the name)
            function normalizeName(name) {
                return name.toLowerCase().replace(/[._\s-]/g, '').trim();
            }
            
            const normalized = normalizeName(nodeName);
            stepIndex = nodeToStepMap.get(normalized);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try partial matching
            for (const [mappedName, mappedStep] of nodeToStepMap.entries()) {
                const mappedNormalized = normalizeName(mappedName);
                if (normalized === mappedNormalized || 
                    normalized.includes(mappedNormalized) || 
                    mappedNormalized.includes(normalized)) {
                    return mappedStep;
                }
            }
            
            return -1;
        }

        // ============================================
        // AR AVAILABILITY CHECK & DESKTOP HANDLING
        // ============================================
        
        // Detect mobile devices
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Check if WebXR is available (for desktop AR)
        async function checkWebXRSupport() {
            if (!navigator.xr) {
                return false;
            }
            
            try {
                // Check if immersive-ar session is supported
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                return supported;
            } catch (e) {
                
                return false;
            }
        }
        
        // Handle AR button visibility and errors
        const arButton = document.querySelector('#ar-button');
        const arRecipeCard = document.querySelector('#ar-recipe-card');
        
        // Track current AR mode
        let currentARMode = null;
        let isInQuickLook = false;
        
        // Get header and recipe name elements
        const header = document.querySelector('#header');
        const recipeName = document.querySelector('#recipe-name');
        
        // Listen for AR status changes with detailed logging
        viewer.addEventListener('ar-status', (event) => {
            const status = event.detail.status;
            const mode = event.detail.mode;
            currentARMode = mode;
            
            
            
            
            
            // Hide header and recipe name when AR is active, show when not
            if (header) {
                if (status === 'presenting' || status === 'session-started' || status === 'object-placed') {
                    header.style.display = 'none';
                    if (recipeName) recipeName.style.display = 'none';
                } else if (status === 'not-presenting') {
                    header.style.display = 'flex';
                    if (recipeName) recipeName.style.display = 'block';
                }
            }
            
            if (status === 'failed') {
                console.error('=== AR INITIALIZATION FAILED ===');
                
                
                
                
                
                
                
                
                
                
                // Check for common issues
                if (!viewer.loaded) {
                    console.error('âŒ Model not loaded - AR cannot initialize');
                }
                if (!viewer.arSupported) {
                    console.error('âŒ AR not supported on this device/browser');
                }
                if (viewer.arModes && viewer.arModes.length === 0) {
                    console.error('âŒ No AR modes available');
                }
                if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                    console.error('âŒ AR requires HTTPS (except localhost)');
                }
                if (mode === 'quick-look' && !viewer.iosSrc) {
                    
                }
                if (mode === 'scene-viewer') {
                    
                    console.log('Android version check:', /Android/.test(navigator.userAgent));
                }
                
            } else if (status === 'session-started') {
                
                console.log('AR mode:', mode || 'webxr (inferred)');
                
                // Show AR recipe card for WebXR mode
                if (arRecipeCard) {
                    // Check if slot is assigned
                    console.log('Slot assignment check:', {
                        assignedSlot: arRecipeCard.assignedSlot,
                        slot: arRecipeCard.slot,
                        parentElement: arRecipeCard.parentElement?.tagName,
                        parentElementId: arRecipeCard.parentElement?.id
                    });
                    
                    // Check element positioning and visibility
                    console.log('AR recipe card check:', {
                        parentElement: arRecipeCard.parentElement?.tagName,
                        parentElementId: arRecipeCard.parentElement?.id,
                        isConnected: arRecipeCard.isConnected
                    });
                    
                    // Force visibility for WebXR DOM overlay
                    // Use requestAnimationFrame to ensure overlay container is ready
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            arRecipeCard.style.display = 'flex';
                            arRecipeCard.style.position = 'fixed';
                            arRecipeCard.style.bottom = '20px';
                            arRecipeCard.style.left = '50%';
                            arRecipeCard.style.transform = 'translateX(-50%)';
                            arRecipeCard.style.zIndex = '99999';
                            arRecipeCard.style.width = '90%';
                            arRecipeCard.style.maxWidth = '500px';
                            arRecipeCard.style.visibility = 'visible';
                            arRecipeCard.style.opacity = '1';
                            arRecipeCard.style.background = 'white';
                            arRecipeCard.style.padding = '16px 20px';
                            arRecipeCard.style.borderRadius = '10px';
                            arRecipeCard.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.2)';
                            
                            console.log('Card dimensions after styling:', {
                                clientHeight: arRecipeCard.clientHeight,
                                clientWidth: arRecipeCard.clientWidth,
                                offsetHeight: arRecipeCard.offsetHeight,
                                offsetWidth: arRecipeCard.offsetWidth,
                                assignedSlot: arRecipeCard.assignedSlot,
                                computedDisplay: window.getComputedStyle(arRecipeCard).display,
                                computedVisibility: window.getComputedStyle(arRecipeCard).visibility,
                                computedPosition: window.getComputedStyle(arRecipeCard).position
                            });
                        });
                    });
                    
                    console.log('âœ… WebXR mode supports HTML overlays (styled via ar-status)');
                } else {
                    console.error('âŒ AR recipe card element not found!');
                }
            } else if (status === 'object-placed') {
                
                console.log('AR mode:', mode || 'webxr (inferred)');
                
                // Ensure AR recipe card remains visible after object placement
                if (arRecipeCard) {
                    setTimeout(() => {
                        arRecipeCard.style.display = 'flex';
                        arRecipeCard.style.position = 'fixed';
                        arRecipeCard.style.bottom = '20px';
                        arRecipeCard.style.left = '50%';
                        arRecipeCard.style.transform = 'translateX(-50%)';
                        arRecipeCard.style.zIndex = '99999';
                        arRecipeCard.style.visibility = 'visible';
                        arRecipeCard.style.opacity = '1';
                        
                        console.log('Card dimensions:', {
                            clientHeight: arRecipeCard.clientHeight,
                            clientWidth: arRecipeCard.clientWidth,
                            offsetHeight: arRecipeCard.offsetHeight,
                            offsetWidth: arRecipeCard.offsetWidth
                        });
                    }, 50);
                }
            } else if (status === 'not-presenting') {
                
                isInQuickLook = false;
                
                // Stop auto-play when exiting AR mode
                stopAutoPlay();
                
                // Switch back to original model when exiting AR mode
                if (CONFIG.arModelPath && viewer.src !== CONFIG.modelPath) {
                    
                    viewer.src = CONFIG.modelPath;
                }
                
                // Hide AR recipe card when exiting AR
                if (arRecipeCard) {
                    arRecipeCard.style.display = 'none';
                }
                
                
                // Make sure button is visible if AR is available
                if (mode === 'webxr' && !isMobileDevice()) {
                    
                    arButton.style.display = '';
                }
            } else if (status === 'presenting') {
                
                
                
                // Switch to compressed model for AR mode (better performance)
                if (CONFIG.arModelPath && viewer.src !== CONFIG.arModelPath) {
                    
                    viewer.src = CONFIG.arModelPath;
                }
                
                // AR recipe card visibility - ensure it's visible for WebXR
                // NOTE: HTML overlays ONLY work with WebXR, NOT Scene Viewer or Quick Look
                if (arRecipeCard) {
                    if (mode === 'webxr' || !mode) {
                        // WebXR mode (or mode not yet determined but status is presenting)
                        
                        console.log('âœ… WebXR mode supports HTML overlays (styled via ar-status)');
                        // Ensure visibility
                        arRecipeCard.style.display = 'flex';
                        arRecipeCard.style.position = 'fixed';
                        arRecipeCard.style.bottom = '20px';
                        arRecipeCard.style.left = '50%';
                        arRecipeCard.style.transform = 'translateX(-50%)';
                        arRecipeCard.style.zIndex = '99999';
                        
                    } else {
                        
                        
                        arRecipeCard.style.display = 'none';
                    }
                    
                    
                } else {
                    console.error('âŒ AR recipe card element not found!');
                }
                
                if (mode === 'quick-look') {
                    isInQuickLook = true;
                    
                    
                    
                    
                    
                    
                    console.warn('âš ï¸ Tap-to-advance (JavaScript) will NOT work in Quick Look');
                    
                    
                    // Quick Look supports animations that are built into the USDZ file itself
                    // We can try to set up the animation to play the full sequence before Quick Look launches
                    // The animation state might carry over when Quick Look opens
                    try {
                        // Set to play the full animation range (all steps)
                        const firstFrame = CONFIG.steps[0].startFrame; // Should be 0
                        const lastFrame = CONFIG.steps[CONFIG.steps.length - 1].endFrame; // Should be 360
                        const startTime = frameToTime(firstFrame);
                        const endTime = frameToTime(lastFrame);
                        
                        viewer.autoplay = true;
                        viewer.loop = false;
                        viewer.currentTime = startTime;
                        viewer.play();
                        
                        
                        console.log(`âœ… Animation duration: ${(endTime - startTime).toFixed(2)}s`);
                        
                    } catch (e) {
                        
                    }
                    
                    setTimeout(() => {
                        descText.innerText = 'Quick Look: Animation should play automatically from USDZ file';
                        titleText.innerText = 'AR Experience';
                    }, 500);
                } else if (mode === 'webxr') {
                    isInQuickLook = false;
                    
                    
                    
                    
                    // Enable autoplay for AR mode
                    viewer.autoplay = true;
                    viewer.loop = false;
                    viewer.currentTime = frameToTime(0);
                    viewer.play();
                    
                    // Start auto-play in AR mode
                    setTimeout(() => {
                        playAllStepsAuto();
                    }, 1000); // Small delay to ensure AR is fully initialized
                } else if (mode === 'scene-viewer') {
                    isInQuickLook = false;
                    console.log('âœ… Scene Viewer AR active (Android)');
                    
                    
                    
                    
                    
                    
                    
                    
                    // Enable autoplay for AR mode
                    viewer.autoplay = true;
                    viewer.loop = false;
                    viewer.currentTime = frameToTime(0);
                    viewer.play();
                    
                    // Start auto-play in AR mode (may work depending on Android version)
                    setTimeout(() => {
                        playAllStepsAuto();
                    }, 1000); // Small delay to ensure AR is fully initialized
                }
            }
        });
        
        // Catch AR launch errors (like the Intent URL error on desktop)
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('intent://')) {
                
                if (!isMobileDevice()) {
                    console.info('Scene Viewer (Android) requires a mobile device.');
                    
                }
            }
        });

        // ============================================
        // iOS QUICK LOOK BANNER TAP LISTENER
        // ============================================
        // Listen for banner taps in Quick Look
        // According to Variant 3D docs, taps trigger a 'message' event
        // See: https://www.variant3d.com/blog/using-banners-in-quicklooks
        viewer.addEventListener('message', (event) => {
            if (event.data === '_apple_ar_quicklook_button_tapped') {
                
                
                // The banner will automatically redirect via canonicalWebPageURL
                // But we can also track this event for analytics
            }
        });
        
        // Check AR availability after model loads
        viewer.addEventListener('load', async () => {
            
            
            
            
            
            
            
            
            const isMobile = isMobileDevice();
            
            // Wait a bit longer for AR to initialize, especially WebXR on desktop
            setTimeout(async () => {
                // Check WebXR support for desktop
                let webXRSupported = false;
                if (!isMobile) {
                    webXRSupported = await checkWebXRSupport();
                    
                    
                    
                    
                    if (webXRSupported) {
                        
                        
                        
                        
                        
                    } else {
                        
                        
                        
                        console.log('2. Ensure HTTPS (or localhost)');
                        console.log('3. Check chrome://flags/#webxr-incubations (if needed)');
                    }
                }
                
                // Only hide button if AR is not available AND WebXR is not supported (on desktop)
                if (!viewer.arAvailable && !isMobile && !webXRSupported) {
                    
                    arButton.style.display = 'none';
                } else if (!viewer.arAvailable && !isMobile && webXRSupported) {
                    
                    arButton.style.display = '';
                }
                
                // Log AR capabilities
                let mobileWebXRSupported = false;
                if (isMobile) {
                    
                    
                    
                    
                    // Check WebXR support on mobile too (for Android)
                    mobileWebXRSupported = await checkWebXRSupport();
                    
                    
                    if (mobileWebXRSupported) {
                        
                        
                        console.log('ðŸ’¡ WebXR supports HTML overlays (styled via ar-status)');
                        
                    } else {
                        
                        console.warn('âš ï¸ Will fall back to Scene Viewer (Android) or Quick Look (iOS)');
                        
                        
                    }
                    
                    if (!viewer.arAvailable) {
                        
                        
                        
                        
                        console.log('3. Missing USDZ file (for iOS)');
                        
                        
                    }
                } else {
                    
                    console.log('AR available (model-viewer):', viewer.arAvailable);
                    
                    if (viewer.arAvailable || webXRSupported) {
                        
                    }
                }
                
                // Store AR capability status globally
                // AR is available if: model-viewer reports it, OR WebXR is supported, OR mobile has AR/WebXR
                hasARCapability = viewer.arAvailable || webXRSupported || (isMobile && (viewer.arAvailable || mobileWebXRSupported));
                
            }, 2000); // Increased timeout to allow WebXR to initialize
        });

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentStepIndex = -1; // Starts before the first step
        let isAnimating = false;
        let hasARCapability = false; // Track if device supports AR

        // ============================================
        // EVENT HANDLERS
        // ============================================


        // Track last click to prevent duplicate processing
        let lastClickTime = 0;
        let lastClickCoords = { x: null, y: null };
        const CLICK_DEBOUNCE_MS = 100; // Prevent rapid duplicate clicks
        
        // OBJECT-SPECIFIC CLICK HANDLER USING RAYCASTING
        viewer.addEventListener('click', (event) => {
            const now = Date.now();
            
            console.log('Click event fired!', {
                target: event.target,
                type: event.type,
                isTrusted: event.isTrusted, // Check if it's a real user interaction
                isInQuickLook: isInQuickLook,
                currentARMode: currentARMode,
                hasRaycaster: !!raycaster,
                hierarchyNodesCount: hierarchyNodes.length
            });
            
            // Only process trusted events (real user interactions)
            if (!event.isTrusted) {
                console.warn('âš ï¸ Ignoring non-trusted event (programmatic click)');
                return;
            }
            
            // Warn if in Quick Look mode
            if (isInQuickLook) {
                
                return;
            }
            
            // If auto-play is running in AR mode, stop it and switch to manual control
            if (isAutoPlaying && currentARMode && currentARMode !== 'not-presenting') {
                
                stopAutoPlay();
            }
            
            // Ignore if animating (unless it's a looping step)
            if (isAnimating && !CONFIG.steps[currentStepIndex]?.loop) {
                
                return;
            }
            
            // Ignore AR button clicks
            if (event.target && (event.target.id === 'ar-button' || event.target.closest('#ar-button'))) {
                
                return;
            }
            
            // Get coordinates - handle both mouse and touch events
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                // Touch event
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                // Touch event (changedTouches for touchend)
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                // Mouse event
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            // VALIDATION: Ensure coordinates are valid numbers
            if (typeof clientX !== 'number' || typeof clientY !== 'number' || 
                isNaN(clientX) || isNaN(clientY)) {
                
                console.warn('Event details:', {
                    hasTouches: !!event.touches,
                    touchesLength: event.touches?.length,
                    hasChangedTouches: !!event.changedTouches,
                    changedTouchesLength: event.changedTouches?.length,
                    clientX: event.clientX,
                    clientY: event.clientY
                });
                return;
            }
            
            // VALIDATION: Ensure coordinates are within viewer bounds
            const rect = viewer.getBoundingClientRect();
            const relativeX = clientX - rect.left;
            const relativeY = clientY - rect.top;
            
            if (relativeX < 0 || relativeX > rect.width || relativeY < 0 || relativeY > rect.height) {
                console.log('Click outside viewer bounds, ignoring:', {
                    clientX, clientY,
                    rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },
                    relative: { x: relativeX, y: relativeY }
                });
                return;
            }
            
            console.log('âœ… Valid click coordinates:', { 
                clientX, 
                clientY,
                relativeX,
                relativeY,
                viewerSize: { width: rect.width, height: rect.height }
            });
            
            // Debounce: Prevent processing duplicate clicks at same location
            const timeSinceLastClick = now - lastClickTime;
            const sameLocation = lastClickCoords.x === clientX && lastClickCoords.y === clientY;
            
            if (timeSinceLastClick < CLICK_DEBOUNCE_MS && sameLocation) {
                console.log('âš ï¸ Ignoring duplicate click at same location:', {
                    timeSinceLastClick,
                    coords: { x: clientX, y: clientY }
                });
                return;
            }
            
            // Update last click tracking
            lastClickTime = now;
            lastClickCoords = { x: clientX, y: clientY };
            
            // Check if raycasting is ready
            if (!raycaster || !hierarchyNodes.length) {
                console.warn('âš ï¸ Raycasting not ready:', {
                    hasRaycaster: !!raycaster,
                    hierarchyNodesCount: hierarchyNodes.length
                });
                descText.innerText = 'Loading... Please wait for model to initialize.';
                return;
            }
            
            // Use raycasting to find hit node
            let nodeName = null;
            try {
                nodeName = findHitNode(clientX, clientY);
            } catch (error) {
                console.error('Error in findHitNode:', error);
                return;
            }
            
            // Log the node name for debugging (preserve the name)
            if (nodeName) {
                
            } else {
                
            }
            
            // Helper function to get next step prompt
            function getNextStepPrompt() {
                if (currentStepIndex < CONFIG.steps.length - 1) {
                    const nextStep = CONFIG.steps[currentStepIndex + 1];
                    return nextStep && nextStep.nextPrompt ? nextStep.nextPrompt : 'Tap to continue';
                }
                return 'Tap to continue';
            }
            
            if (!nodeName) {
                // Clicked on empty space - show next step prompt
                descText.innerText = getNextStepPrompt();
                return;
            }
            
            // Find which step this node belongs to
            const objectStepIndex = getStepIndexForNode(nodeName);
            
            
            if (objectStepIndex === -1) {
                // Clicked node is not interactive
                
                descText.innerText = getNextStepPrompt();
                return;
            }
            
            // Check if this is the correct step to advance
            const expectedStepIndex = currentStepIndex + 1;
            
            if (objectStepIndex === expectedStepIndex) {
                // Correct object clicked - advance!
                
                playNextStep();
            } else if (objectStepIndex < expectedStepIndex) {
                // Clicked an object from a previous step
                
                descText.innerText = getNextStepPrompt();
            } else {
                // Clicked an object from a future step
                
                descText.innerText = getNextStepPrompt();
            }
        });
        
        // Also listen for touchstart/touchend to catch mobile taps
        viewer.addEventListener('touchstart', (event) => {
            
            // Let the click handler process it
        });
        
        viewer.addEventListener('touchend', (event) => {
            
            // Let the click handler process it
        });

        // ============================================
        // WELCOME CARD CLICK HANDLER (for in-browser 3D viewer)
        // ============================================
        
        // Make the welcome card clickable to trigger animations
        if (card) {
            card.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent event from bubbling to viewer
                
                // Only work in non-AR mode (object mode / 3D viewer)
                if (currentARMode && currentARMode !== 'not-presenting') {
                    
                    return;
                }
                
                // Check if step 6 is completed
                const isStep6Completed = currentStepIndex === CONFIG.steps.length - 1;
                
                // Ignore if animating (unless it's a looping step OR step 6 is completed)
                // Allow clicks after step 6 completes even if animation flag is still set
                if (isAnimating && !CONFIG.steps[currentStepIndex]?.loop && !isStep6Completed) {
                    
                    return;
                }
                
                
                
                // Check if step 6 is completed - if so, launch AR or redirect
                if (isStep6Completed) {
                    if (hasARCapability) {
                        // Step 6 completed and device has AR - launch AR with compressed model
                        launchARWithCompressedModel();
                    } else {
                        // Step 6 completed but no AR - redirect to recipe page
                        window.location.href = 'https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona';
                    }
                } else if (currentStepIndex < CONFIG.steps.length - 1) {
                    // Advance to next step
                    playNextStep();
                } else {
                    // All steps completed - restart
                    
                    resetExperience();
                    // Then play first step
                    setTimeout(() => {
                        playNextStep();
                    }, 100);
                }
            });
            
            
        }

        // ============================================
        // AR RECIPE CARD HANDLER
        // ============================================
        
        // Handle AR recipe card clicks (opens in new tab)
        // Note: Card is now inside model-viewer, styled via ar-status attribute
        // so it's automatically projected onto the AR camera feed via WebXR DOM Overlay
        if (arRecipeCard) {
            // Prevent clicks on card from bubbling to viewer
            arRecipeCard.addEventListener('click', (event) => {
                event.stopPropagation();
            });
            
            // Log when recipe is accessed
            const recipeLinks = arRecipeCard.querySelectorAll('a');
            recipeLinks.forEach(link => {
                link.addEventListener('click', () => {
                    
                });
            });
            
            console.log('âœ… AR recipe card handlers attached (WebXR DOM Overlay)');
        }

        // ============================================
        // PLAYBACK FUNCTIONS
        // ============================================

        // Function to launch AR with compressed model
        function launchARWithCompressedModel() {
            
            
            // Switch to compressed model for AR
            if (CONFIG.arModelPath && viewer.src !== CONFIG.arModelPath) {
                const previousSrc = viewer.src;
                viewer.src = CONFIG.arModelPath;
                
                
                // Wait for model to load, then activate AR
                const activateARAfterLoad = () => {
                    viewer.removeEventListener('load', activateARAfterLoad);
                    activateAR();
                };
                
                viewer.addEventListener('load', activateARAfterLoad, { once: true });
            } else {
                // Model already set, activate AR immediately
                activateAR();
            }
            
            function activateAR() {
                // Create a temporary AR button and trigger it
                // This is the most reliable way to activate AR in model-viewer
                const tempButton = document.createElement('button');
                tempButton.slot = 'ar-button';
                tempButton.style.cssText = 'display: none; position: absolute; opacity: 0; pointer-events: none;';
                tempButton.setAttribute('aria-label', 'Launch AR');
                viewer.appendChild(tempButton);
                
                // Wait a moment for button to be registered, then trigger click
                setTimeout(() => {
                    try {
                        // Try multiple methods to trigger AR
                        if (tempButton.click) {
                            tempButton.click();
                        } else if (tempButton.dispatchEvent) {
                            const clickEvent = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                view: window
                            });
                            tempButton.dispatchEvent(clickEvent);
                        }
                        
                    } catch (error) {
                        console.error('âŒ Error triggering AR:', error);
                        // Fallback: show message to user
                        descText.innerText = 'Please use your browser\'s AR button to view in AR';
                    } finally {
                        // Clean up after a delay
                        setTimeout(() => {
                            if (tempButton.parentNode) {
                                tempButton.remove();
                            }
                        }, 1000);
                    }
                }, 200);
            }
        }

        function playNextStep() {
            currentStepIndex++;
            const stepData = CONFIG.steps[currentStepIndex];

            // Check if this is the last step (step 6)
            const isLastStep = currentStepIndex === CONFIG.steps.length - 1;

            // Update UI - use step's title and desc directly
            titleText.innerText = stepData.title;
            descText.innerText = stepData.desc;
            
            // Note: Last step completion is handled by handleStep6Completion() in playKeyframeRange
            isAnimating = true;

            // Play the keyframe range
            playKeyframeRange(stepData);
        }

        // Function to handle step 6 completion based on AR capability
        function handleStep6Completion() {
            const step6Data = CONFIG.steps[CONFIG.steps.length - 1];
            
            if (hasARCapability) {
                // Device has AR - show welcome card with AR prompt
                titleText.innerText = step6Data.title;
                descText.innerText = step6Data.desc;
                // Ensure welcome card is visible
                if (card) {
                    card.style.display = 'inline-block';
                }
                // Hide AR recipe card if it was shown
                const arRecipeCard = document.querySelector('#ar-recipe-card');
                if (arRecipeCard) {
                    arRecipeCard.classList.remove('show-in-viewer');
                }
            } else {
                // Device doesn't have AR - show recipe message on welcome card
                titleText.innerText = 'Discover 30 days of Nescafe recipes this Ramadan.';
                descText.innerText = '';
                // Ensure welcome card is visible
                if (card) {
                    card.style.display = 'inline-block';
                }
                // Hide AR recipe card
                const arRecipeCard = document.querySelector('#ar-recipe-card');
                if (arRecipeCard) {
                    arRecipeCard.classList.remove('show-in-viewer');
                }
            }
        }

        function resetExperience() {
            currentStepIndex = -1;
            titleText.innerText = CONFIG.resetTitle;
            descText.innerText = CONFIG.resetDesc;
            
            // Reset to first frame
            viewer.currentTime = frameToTime(0);
            viewer.pause();
            isAnimating = false;
            
            // Reset UI cards
            if (card) {
                card.style.display = 'inline-block';
            }
            const arRecipeCard = document.querySelector('#ar-recipe-card');
            if (arRecipeCard) {
                arRecipeCard.classList.remove('show-in-viewer');
            }
        }

        // Auto-play all steps in sequence (for AR mode)
        let autoPlayTimeout = null;
        let isAutoPlaying = false;

        function playAllStepsAuto() {
            if (isAutoPlaying) {
                
                return;
            }

            
            isAutoPlaying = true;
            
            // Reset to beginning
            currentStepIndex = -1;
            viewer.currentTime = frameToTime(0);
            viewer.pause();
            isAnimating = false;

            // Start playing steps automatically
            function playNextAutoStep() {
                if (currentStepIndex >= CONFIG.steps.length - 1) {
                    // All steps completed
                    
                    isAutoPlaying = false;
                    const lastStep = CONFIG.steps[CONFIG.steps.length - 1];
                    titleText.innerText = lastStep.title;
                    // Handle step 6 completion based on AR capability
                    handleStep6Completion();
                    
                    // Recipe link doesn't need reset (it's just a link)
                    return;
                }

                // Advance to next step
                currentStepIndex++;
                const stepData = CONFIG.steps[currentStepIndex];
                
                

                // Update UI - use step's title and desc directly
                titleText.innerText = stepData.title;
                descText.innerText = stepData.desc;
                
                // Note: Last step completion is handled by handleStep6Completion() in checkAutoPlayback
                isAnimating = true;

                // Play the keyframe range
                const startTime = frameToTime(stepData.startFrame);
                const endTime = frameToTime(stepData.endFrame);
                
                viewer.currentTime = startTime;
                viewer.play();
                viewer.loop = stepData.loop || false;

                // Calculate duration for this step
                const stepDuration = (endTime - startTime) * 1000; // Convert to milliseconds

                // Monitor playback and advance to next step when done
                function checkAutoPlayback() {
                    if (!isAutoPlaying) return; // Stop if auto-play was cancelled

                    if (viewer.currentTime >= endTime) {
                        // Ensure we're exactly on the final frame
                        viewer.currentTime = endTime;
                        viewer.pause();
                        isAnimating = false;
                        
                        // Wait a brief moment before next step, then continue
                        autoPlayTimeout = setTimeout(() => {
                            playNextAutoStep();
                        }, 500); // 500ms pause between steps
                    } else {
                        requestAnimationFrame(checkAutoPlayback);
                    }
                }
                
                requestAnimationFrame(checkAutoPlayback);
            }

            // Start the sequence after a short delay
            setTimeout(() => {
                playNextAutoStep();
            }, 1000); // 1 second delay before starting
        }

        function stopAutoPlay() {
            if (autoPlayTimeout) {
                clearTimeout(autoPlayTimeout);
                autoPlayTimeout = null;
            }
            isAutoPlaying = false;
            isAnimating = false;
            
            
                    // Recipe link doesn't need reset (it's just a link)
        }

        // ============================================
        // ERROR HANDLING
        // ============================================
        
        viewer.addEventListener('error', (event) => {
            console.error('Model loading error:', event.detail);
            titleText.innerText = 'Error';
            descText.innerText = 'Failed to load 3D model. Check console for details.';
        });

        viewer.addEventListener('load', () => {
            
            console.log('Click handler ready:', {
                hasRaycaster: !!raycaster,
                hierarchyNodesCount: hierarchyNodes.length,
                currentStepIndex: currentStepIndex,
                totalSteps: CONFIG.steps.length
            });
            
            // Test click detection setup
            if (!raycaster || !hierarchyNodes.length) {
                
                setTimeout(() => {
                    setupHitDetection();
                }, 500);
            } else {
                
            }
        });

        // ============================================
        // HELPER: Debug object names
        // ============================================

        // Uncomment to debug object names:
        // viewer.addEventListener('load', () => {
        //     const scene = viewer.getScene();
        //     
        //     scene.traverse((object) => {
        //         if (object.isMesh) {
        //             
        //         }
        //     });
        // });

    </script>
</body>
</html>

