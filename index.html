<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tap-to-Advance AR Experience</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    
    <style>
        /* --- CSS STYLING --- */
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Helvetica', 'Arial', sans-serif; 
            overflow: hidden; 
        }
        
        /* The AR Window */
        model-viewer {
            width: 100vw;
            height: 100vh;
            background-color: #f5f5f5; /* Fallback color */
            --poster-color: #f5f5f5;
        }

        /* The UI Overlay Container */
        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Let taps pass through to the 3D model */
            z-index: 100;
        }

        /* The Branding / Instruction Card */
        .card {
            display: inline-block;
            background: white;
            padding: 16px 24px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .card h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card p {
            margin: 4px 0 0 0;
            font-size: 14px;
            color: #555;
        }

        /* Hide UI while loading */
        model-viewer:not([loaded]) #ui-layer { 
            opacity: 0; 
        }

        /* Custom AR Button Styling */
        #ar-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 200;
            cursor: pointer;
            transition: background 0.2s;
        }

        #ar-button:hover {
            background: #0056CC;
        }
    </style>
</head>
<body>

    <model-viewer 
        id="ar-viewer"
        src="assets/Dalgona-OneTake_0001.glb"
        ios-src="assets/model.usdz"
        ar
        ar-modes="webxr scene-viewer quick-look"
        camera-controls
        disable-zoom
        shadow-intensity="1.2"
        environment-image="neutral" 
        tone-mapping="commerce"
        animation-name="animation_0"
        autoplay="false">
        
        <button slot="ar-button" id="ar-button">
            View in your space
        </button>
    </model-viewer>

    <div id="ui-layer">
        <div class="card" id="info-card">
            <h2 id="step-title">Welcome</h2>
            <p id="step-desc">Tap the Nescafé sachet to start!</p>
        </div>
    </div>

    <script type="module">
        // ============================================
        // ON-SCREEN CONSOLE FOR MOBILE DEBUGGING
        // ============================================
        
        function createOnScreenConsole() {
            const consoleDiv = document.createElement('div');
            consoleDiv.id = 'mobile-console';
            consoleDiv.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 200px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.95);
                color: #0f0;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 8px;
                z-index: 10000;
                display: none;
                border-top: 2px solid #0f0;
                box-shadow: 0 -2px 10px rgba(0, 255, 0, 0.3);
            `;
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '✕';
            closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: #f00;
                color: white;
                border: none;
                border-radius: 3px;
                width: 24px;
                height: 24px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                z-index: 10001;
            `;
            closeBtn.onclick = () => {
                consoleDiv.style.display = 'none';
            };
            consoleDiv.appendChild(closeBtn);
            
            // Add clear button
            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 35px;
                background: #333;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 8px;
                cursor: pointer;
                font-size: 10px;
                z-index: 10001;
            `;
            clearBtn.onclick = () => {
                const logs = consoleDiv.querySelectorAll('div:not(button)');
                logs.forEach(log => log.remove());
            };
            consoleDiv.appendChild(clearBtn);
            
            document.body.appendChild(consoleDiv);
            
            // Store original console methods
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;
            
            function addToScreen(type, ...args) {
                const consoleDiv = document.getElementById('mobile-console');
                if (!consoleDiv) return;
                
                const message = args.map(arg => {
                    if (arg === null) return 'null';
                    if (arg === undefined) return 'undefined';
                    if (typeof arg === 'object') {
                        try {
                            return JSON.stringify(arg, null, 2);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return String(arg);
                }).join(' ');
                
                const logEntry = document.createElement('div');
                logEntry.style.cssText = `
                    padding: 3px 0;
                    border-bottom: 1px solid #222;
                    word-wrap: break-word;
                    color: ${type === 'error' ? '#ff4444' : type === 'warn' ? '#ffaa00' : type === 'info' ? '#00aaff' : '#00ff00'};
                    white-space: pre-wrap;
                `;
                
                const timestamp = new Date().toLocaleTimeString();
                logEntry.textContent = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
                consoleDiv.appendChild(logEntry);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                
                // Auto-show console for errors and warnings
                if (type === 'error' || type === 'warn') {
                    consoleDiv.style.display = 'block';
                }
            }
            
            // Override console methods
            console.log = function(...args) {
                originalLog.apply(console, args);
                addToScreen('log', ...args);
            };
            
            console.error = function(...args) {
                originalError.apply(console, args);
                addToScreen('error', ...args);
            };
            
            console.warn = function(...args) {
                originalWarn.apply(console, args);
                addToScreen('warn', ...args);
            };
            
            console.info = function(...args) {
                if (originalInfo) originalInfo.apply(console, args);
                addToScreen('info', ...args);
            };
            
            // Toggle console with triple tap
            let tapCount = 0;
            let tapTimer = null;
            document.addEventListener('touchstart', (e) => {
                // Don't trigger on UI elements
                if (e.target.tagName === 'BUTTON' || e.target.closest('#ui-layer')) {
                    return;
                }
                
                tapCount++;
                clearTimeout(tapTimer);
                tapTimer = setTimeout(() => {
                    if (tapCount === 3) {
                        const consoleDiv = document.getElementById('mobile-console');
                        if (consoleDiv) {
                            consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                        }
                    }
                    tapCount = 0;
                }, 400);
            });
            
            // Also allow keyboard toggle (for desktop testing)
            document.addEventListener('keydown', (e) => {
                if (e.key === '`' && e.ctrlKey) {
                    e.preventDefault();
                    const consoleDiv = document.getElementById('mobile-console');
                    if (consoleDiv) {
                        consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                    }
                }
            });
            
            console.log('On-screen console initialized. Triple-tap to toggle, or press Ctrl+`');
        }
        
        // Initialize console immediately
        createOnScreenConsole();
        
        // ============================================
        // CONFIGURATION: Keyframe-based animation with object-specific taps
        // ============================================
        
        const CONFIG = {
            // Path to your 3D model (GLB format)
            modelPath: 'assets/Dalgona-OneTake_0001.glb',
            
            // Path to iOS USDZ format (optional, for better iOS support)
            iosModelPath: 'assets/model.usdz',
            
            // Animation name (single track)
            animationName: 'animation_0',
            
            // Frame rate of your animation
            fps: 30,
            
            // Keyframe spans for each step
            steps: [
                { 
                    startFrame: 1,
                    endFrame: 80,
                    title: 'Step 1: The Mix', 
                    desc: 'Nescafé + Water into bowl',
                    objectHint: 'Tap the Nescafé sachet, pot, or handle'
                },
                { 
                    startFrame: 80,
                    endFrame: 140,
                    title: 'Step 2: Whip It', 
                    desc: 'Whisking into foam...',
                    objectHint: 'Tap the whisk'
                },
                { 
                    startFrame: 140,
                    endFrame: 200,
                    title: 'Step 3: The Base', 
                    desc: 'Milk into mug...',
                    objectHint: 'Tap the jug'
                },
                { 
                    startFrame: 200,
                    endFrame: 240,
                    title: 'Step 4: Transfer', 
                    desc: 'Bowl into mug...',
                    objectHint: 'Tap the mixing bowl'
                },
                { 
                    startFrame: 240,
                    endFrame: 300,
                    title: 'Step 5: Final Touch', 
                    desc: 'Add ice...',
                    objectHint: 'Tap the scoop or ice bowl',
                    loop: false
                }
            ],
            
            // Object names that trigger each step (must match GLB mesh names)
            interactiveObjects: [
                ['Nescafe.BTM', 'Nescafe.TOP (Copy)', 'pot', 'handle'],  // Step 1
                ['whisk'],                                                // Step 2
                ['jug'],                                                  // Step 3
                ['mixing.bowl'],                                          // Step 4
                ['scoop', 'ice.bowl']                                     // Step 5
            ],
            
            // Welcome message
            welcomeTitle: 'Welcome',
            welcomeDesc: 'Tap the Nescafé sachet to start!',
            
            // Continue prompt
            continuePrompt: 'Tap the correct object to continue ->',
            
            // Reset message
            resetTitle: 'Replay?',
            resetDesc: 'Tap to start again.',
            
            // Visual feedback for interactive objects
            enableHoverFeedback: true
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        
        const viewer = document.querySelector('#ar-viewer');
        const titleText = document.querySelector('#step-title');
        const descText = document.querySelector('#step-desc');
        const card = document.querySelector('#info-card');

        // Set model paths from config
        viewer.src = CONFIG.modelPath;
        if (CONFIG.iosModelPath) {
            viewer.setAttribute('ios-src', CONFIG.iosModelPath);
        }
        viewer.animationName = CONFIG.animationName;
        viewer.autoplay = false;
        viewer.loop = false;

        // Set welcome message
        titleText.innerText = CONFIG.welcomeTitle;
        descText.innerText = CONFIG.welcomeDesc;

        // ============================================
        // THREE.JS RAYCASTING SETUP
        // ============================================
        
        let raycaster = null;
        let camera = null;
        let scene = null;
        let mouse = null; // Will be initialized when THREE is available
        let interactiveMeshes = new Map(); // Cache of interactive objects
        let animationCheckInterval = null;

        // Initialize raycasting after model loads
        viewer.addEventListener('load', () => {
            // Wait a bit for model-viewer to fully initialize
            setTimeout(() => {
                setupRaycasting();
                // Set initial time to frame 1
                viewer.currentTime = frameToTime(1);
                viewer.pause();
            }, 500); // Increased delay to ensure model is fully loaded
        });
        
        // Also listen for scene-graph-ready event if available
        viewer.addEventListener('scene-graph-ready', () => {
            console.log('Scene graph ready event fired');
            setupRaycasting();
        });

        function setupRaycasting() {
            // Try multiple ways to access the scene from model-viewer
            let potentialScene = null;
            
            console.log('=== Attempting to access scene ===');
            
            // Method 1: Try renderRoot (Shadow DOM access point)
            if (viewer.renderRoot) {
                console.log('Found renderRoot, checking properties...');
                const renderRoot = viewer.renderRoot;
                const renderRootKeys = Object.keys(renderRoot);
                console.log('renderRoot keys:', renderRootKeys);
                
                // Recursively search for scene in renderRoot
                function findSceneInObject(obj, path = 'renderRoot', depth = 0) {
                    if (depth > 3 || !obj || typeof obj !== 'object') return null;
                    
                    // Check if this is a Three.js Scene
                    if (obj.type === 'Scene' && typeof obj.traverse === 'function') {
                        console.log('✓ Found Scene at:', path);
                        return obj;
                    }
                    
                    // Check if it has a scene property
                    if (obj.scene && typeof obj.scene.traverse === 'function') {
                        console.log('✓ Found scene property at:', path);
                        return obj.scene;
                    }
                    
                    // Check common Three.js renderer properties
                    if (obj.domElement && obj.scene) {
                        console.log('✓ Found renderer-like object at:', path);
                        if (typeof obj.scene.traverse === 'function') {
                            return obj.scene;
                        }
                    }
                    
                    // Recursively check properties (skip circular refs and common non-scene props)
                    const skipKeys = ['parent', 'children', '__proto__', 'prototype', 'constructor'];
                    for (const key in obj) {
                        if (skipKeys.includes(key) || key.startsWith('__')) continue;
                        try {
                            const value = obj[key];
                            if (value && typeof value === 'object' && value !== obj) {
                                const result = findSceneInObject(value, `${path}.${key}`, depth + 1);
                                if (result) return result;
                            }
                        } catch (e) {
                            // Skip circular references
                        }
                    }
                    
                    return null;
                }
                
                potentialScene = findSceneInObject(renderRoot);
            }
            
            // Method 2: Try accessing through Shadow DOM canvas
            if (!potentialScene && viewer.renderRoot) {
                const shadowRoot = viewer.renderRoot.shadowRoot;
                if (shadowRoot) {
                    const canvas = shadowRoot.querySelector('canvas');
                    if (canvas) {
                        console.log('Found canvas, checking WebGL context...');
                        // WebGL context might have references to Three.js objects
                        const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
                        if (gl) {
                            console.log('Found WebGL context');
                            // Try to find scene through canvas properties
                            for (const key in canvas) {
                                const value = canvas[key];
                                if (value && typeof value === 'object' && value.scene) {
                                    if (typeof value.scene.traverse === 'function') {
                                        potentialScene = value.scene;
                                        console.log('✓ Found scene through canvas[' + key + ']');
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Method 3: Check viewer.model (even though it's empty)
            if (!potentialScene && viewer.model) {
                const model = viewer.model;
                const modelKeys = Object.keys(model);
                console.log('Checking model keys:', modelKeys);
                
                for (const key of modelKeys) {
                    const value = model[key];
                    if (value && typeof value === 'object') {
                        if (value.scene && typeof value.scene.traverse === 'function') {
                            potentialScene = value.scene;
                            console.log('✓ Found scene in model[' + key + ']');
                            break;
                        }
                        if (typeof value.traverse === 'function' && value.type === 'Scene') {
                            potentialScene = value;
                            console.log('✓ Found scene object in model[' + key + ']');
                            break;
                        }
                    }
                }
            }
            
            console.log('potentialScene result:', potentialScene);
            
            if (!potentialScene) {
                console.warn('Scene not found in initial attempt, trying delayed access...');
                setTimeout(() => {
                    tryDelayedSceneAccess();
                }, 2000);
                return;
            }
            
            scene = potentialScene;
            continueRaycastingSetup();
        }
        
        function tryDelayedSceneAccess() {
            console.log('=== Delayed scene access attempt ===');
            let potentialScene = null;
            
            // Try renderRoot again with deeper search
            if (viewer.renderRoot) {
                const renderRoot = viewer.renderRoot;
                console.log('Delayed: Checking renderRoot more deeply...');
                
                // Try accessing all properties more aggressively
                for (const key in renderRoot) {
                    try {
                        const value = renderRoot[key];
                        if (value && typeof value === 'object') {
                            console.log(`Checking renderRoot.${key}:`, typeof value);
                            
                            // Check if it's a renderer
                            if (value.scene && typeof value.scene.traverse === 'function') {
                                potentialScene = value.scene;
                                console.log('✓ Found scene in delayed renderRoot[' + key + ']');
                                break;
                            }
                            
                            // Check nested properties
                            if (value.renderer && value.renderer.scene) {
                                if (typeof value.renderer.scene.traverse === 'function') {
                                    potentialScene = value.renderer.scene;
                                    console.log('✓ Found scene in delayed renderRoot[' + key + '].renderer');
                                    break;
                                }
                            }
                        }
                    } catch (e) {
                        // Skip inaccessible properties
                    }
                }
            }
            
            if (potentialScene) {
                scene = potentialScene;
                continueRaycastingSetup();
            } else {
                console.error('Scene still not accessible after delayed attempt.');
                console.log('Object-specific tap detection will be disabled.');
                console.log('Keyframe-based animation will still work.');
            }
        }
        
        function continueRaycastingSetup() {
            if (!scene) {
                console.error('Scene is null, cannot setup raycasting');
                return;
            }
            
            if (typeof scene.traverse !== 'function') {
                console.error('Scene object does not have traverse method');
                console.log('scene type:', scene.constructor?.name);
                console.log('scene keys:', Object.keys(scene));
                return;
            }
            
            console.log('✓ Scene validated, proceeding with raycasting setup');
            
            // Import Three.js dynamically (we need it for raycasting anyway)
            // This will cause a warning about multiple instances, but it's necessary
            if (!window.THREE) {
                import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js').then((THREE) => {
                    window.THREE = THREE;
                    initializeRaycasting();
                }).catch((err) => {
                    console.error('Failed to import Three.js:', err);
                });
                return;
            }
            
            initializeRaycasting();
        }
        
        function tryAlternativeSceneAccess() {
            console.log('=== Trying alternative scene access ===');
            
            // Try accessing through renderRoot more deeply
            if (viewer.renderRoot) {
                // Try to access internal Three.js objects
                // Model-viewer stores them in private properties
                const renderRoot = viewer.renderRoot;
                
                // Check all properties recursively
                function findSceneInObject(obj, path = '') {
                    if (!obj || typeof obj !== 'object') return null;
                    
                    // Check if this is a Three.js Scene
                    if (obj.type === 'Scene' && typeof obj.traverse === 'function') {
                        console.log('Found Scene at:', path);
                        return obj;
                    }
                    
                    // Check if it has a scene property
                    if (obj.scene && typeof obj.scene.traverse === 'function') {
                        console.log('Found scene property at:', path);
                        return obj.scene;
                    }
                    
                    // Recursively check properties (limit depth to avoid infinite loops)
                    if (path.split('.').length < 5) {
                        for (const key in obj) {
                            if (key.startsWith('_') || key === 'parent' || key === 'children') continue;
                            try {
                                const result = findSceneInObject(obj[key], path ? `${path}.${key}` : key);
                                if (result) return result;
                            } catch (e) {
                                // Skip circular references
                            }
                        }
                    }
                    
                    return null;
                }
                
                const foundScene = findSceneInObject(renderRoot, 'renderRoot');
                if (foundScene) {
                    scene = foundScene;
                    console.log('Scene found through recursive search!');
                    initializeRaycasting();
                    return;
                }
            }
            
            console.error('Could not find scene through any method.');
            console.log('Object-specific tap detection will not work.');
            console.log('Consider using model-viewer\'s built-in interaction system instead.');
        }
        
        function initializeRaycasting() {
            const THREE = window.THREE;
            
            if (!THREE) {
                console.error('THREE.js not available');
                return;
            }
            
            // Get camera from model-viewer
            if (viewer.camera) {
                camera = viewer.camera;
            } else {
                // Try to find camera in the scene
                scene.traverse((object) => {
                    if (object.isCamera && !camera) {
                        camera = object;
                    }
                });
            }
            
            // Initialize mouse vector
            if (!mouse) {
                mouse = new THREE.Vector2();
            }
            
            // Create raycaster
            raycaster = new THREE.Raycaster();
            
            // Find and cache all interactive objects
            findInteractiveObjects();
            
            console.log('Raycasting initialized. Interactive objects:', Array.from(interactiveMeshes.keys()));
        }

        function findInteractiveObjects() {
            if (!scene) return;
            
            // Traverse the scene to find objects
            scene.traverse((object) => {
                // Check if this object matches any of our interactive object names
                const objectName = object.name || '';
                
                // Check against configured interactive objects
                CONFIG.interactiveObjects.forEach((targetNames, stepIndex) => {
                    // Handle both string and array formats
                    const names = Array.isArray(targetNames) ? targetNames : [targetNames];
                    
                    names.forEach(name => {
                        // Match by exact name (case-sensitive)
                        if (objectName === name) {
                            // Only mesh objects can be clicked
                            if (object.isMesh) {
                                // Store reference with step index
                                if (!interactiveMeshes.has(stepIndex)) {
                                    interactiveMeshes.set(stepIndex, []);
                                }
                                interactiveMeshes.get(stepIndex).push(object);
                                
                                // Enable hover feedback if configured
                                if (CONFIG.enableHoverFeedback) {
                                    setupHoverFeedback(object);
                                }
                            }
                        }
                    });
                });
            });
            
            // If no objects found, log available object names for debugging
            if (interactiveMeshes.size === 0) {
                console.warn('No interactive objects found. Available objects:');
                scene.traverse((object) => {
                    if (object.isMesh) {
                        console.log('-', object.name || '(unnamed)');
                    }
                });
            }
        }

        // ============================================
        // HOVER FEEDBACK (Optional)
        // ============================================

        function setupHoverFeedback(object) {
            const originalMaterial = object.material;
            
            // Create hover material (slightly brighter/emissive)
            const hoverMaterial = originalMaterial.clone();
            if (hoverMaterial.emissive) {
                hoverMaterial.emissive.setHex(0x444444);
            }
            
            // Store original material
            object.userData.originalMaterial = originalMaterial;
            object.userData.hoverMaterial = hoverMaterial;
        }

        function updateHoverFeedback(event) {
            if (!CONFIG.enableHoverFeedback || !raycaster) return;
            
            const intersectedObject = getIntersectedObject(event);
            
            // Reset all objects to original material
            interactiveMeshes.forEach((objects) => {
                objects.forEach(obj => {
                    if (obj.userData && obj.userData.originalMaterial) {
                        obj.material = obj.userData.originalMaterial;
                    }
                });
            });
            
            // Highlight hovered object
            if (intersectedObject) {
                const stepIndex = getStepIndexForObject(intersectedObject);
                if (stepIndex !== -1 && intersectedObject.userData && intersectedObject.userData.hoverMaterial) {
                    intersectedObject.material = intersectedObject.userData.hoverMaterial;
                    viewer.style.cursor = 'pointer';
                } else {
                    viewer.style.cursor = 'default';
                }
            } else {
                viewer.style.cursor = 'default';
            }
        }

        // ============================================
        // KEYFRAME-BASED PLAYBACK FUNCTIONS
        // ============================================

        // Convert frame number to time in seconds
        function frameToTime(frame, fps = CONFIG.fps) {
            return frame / fps;
        }

        // Play a specific keyframe range
        function playKeyframeRange(stepData) {
            const startTime = frameToTime(stepData.startFrame);
            const endTime = frameToTime(stepData.endFrame);
            
            // Set the start time
            viewer.currentTime = startTime;
            
            // Play the animation
            viewer.play();
            viewer.loop = stepData.loop || false;
            
            // Monitor playback using requestAnimationFrame for smooth control
            function checkPlayback() {
                if (!isAnimating) return; // Stop if user advanced
                
                if (viewer.currentTime >= endTime) {
                    viewer.pause();
                    isAnimating = false;
                    
                    if (stepData.loop) {
                        // Restart this range
                        viewer.currentTime = startTime;
                        viewer.play();
                        requestAnimationFrame(checkPlayback);
                    } else {
                        // Finished
                        if (currentStepIndex < CONFIG.steps.length - 1) {
                            descText.innerText = CONFIG.continuePrompt;
                        }
                    }
                } else {
                    requestAnimationFrame(checkPlayback);
                }
            }
            
            requestAnimationFrame(checkPlayback);
        }

        // ============================================
        // OBJECT-SPECIFIC CLICK DETECTION
        // ============================================

        function getIntersectedObject(event) {
            if (!raycaster || !scene || !mouse) {
                return null;
            }
            
            // Ensure camera is available
            if (!camera) {
                if (viewer.camera) {
                    camera = viewer.camera;
                } else {
                    // Try to find camera in scene
                    scene.traverse((object) => {
                        if (object.isCamera && !camera) {
                            camera = object;
                        }
                    });
                }
            }
            
            if (!camera) {
                return null;
            }
            
            // Get mouse/touch position in normalized device coordinates (-1 to +1)
            const rect = viewer.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0]?.clientX) || 0;
            const clientY = event.clientY || (event.touches && event.touches[0]?.clientY) || 0;
            
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster with camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Get all meshes in the scene for intersection testing
            const meshes = [];
            if (scene && typeof scene.traverse === 'function') {
                scene.traverse((object) => {
                    if (object.isMesh) {
                        meshes.push(object);
                    }
                });
            }
            
            // Calculate intersections
            const intersects = raycaster.intersectObjects(meshes, true);
            
            if (intersects.length > 0) {
                return intersects[0].object;
            }
            
            return null;
        }

        function getStepIndexForObject(object) {
            if (!object) return -1;
            
            // Find which step this object belongs to
            for (const [stepIndex, objects] of interactiveMeshes.entries()) {
                if (objects.includes(object)) {
                    return stepIndex;
                }
            }
            
            return -1;
        }

        // ============================================
        // AR AVAILABILITY CHECK & DESKTOP HANDLING
        // ============================================
        
        // Detect mobile devices
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Handle AR button visibility and errors
        const arButton = document.querySelector('#ar-button');
        
        // Listen for AR status changes
        viewer.addEventListener('ar-status', (event) => {
            console.log('AR status:', event.detail.status);
        });
        
        // Catch AR launch errors (like the Intent URL error on desktop)
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('intent://')) {
                console.warn('AR Intent URL not supported on this device');
                if (!isMobileDevice()) {
                    console.info('AR is only available on mobile devices. Please open this page on your phone or tablet.');
                }
            }
        });
        
        // Check AR availability after model loads
        viewer.addEventListener('load', () => {
            setTimeout(() => {
                if (!viewer.arAvailable && !isMobileDevice()) {
                    arButton.style.display = 'none';
                }
            }, 1000);
        });

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentStepIndex = -1; // Starts before the first step
        let isAnimating = false;

        // ============================================
        // EVENT HANDLERS
        // ============================================

        // OBJECT-SPECIFIC CLICK HANDLER
        viewer.addEventListener('click', (event) => {
            // Ignore if animating (unless it's a looping step)
            if (isAnimating && !CONFIG.steps[currentStepIndex]?.loop) return;
            
            // Ignore AR button clicks
            if (event.target.id === 'ar-button') return;
            
            // Get the clicked object
            const clickedObject = getIntersectedObject(event);
            
            if (!clickedObject) {
                // Clicked on empty space - show feedback
                if (currentStepIndex >= 0 && currentStepIndex < CONFIG.steps.length) {
                    const stepData = CONFIG.steps[currentStepIndex];
                    descText.innerText = stepData.objectHint || CONFIG.continuePrompt;
                }
                return;
            }
            
            // Find which step this object belongs to
            const objectStepIndex = getStepIndexForObject(clickedObject);
            
            if (objectStepIndex === -1) {
                // Clicked object is not interactive
                console.log('Clicked object is not interactive:', clickedObject.name);
                if (currentStepIndex >= 0 && currentStepIndex < CONFIG.steps.length) {
                    const stepData = CONFIG.steps[currentStepIndex];
                    descText.innerText = stepData.objectHint || CONFIG.continuePrompt;
                }
                return;
            }
            
            // Check if this is the correct step to advance
            const expectedStepIndex = currentStepIndex + 1;
            
            if (objectStepIndex === expectedStepIndex) {
                // Correct object clicked - advance!
                playNextStep();
            } else if (objectStepIndex < expectedStepIndex) {
                // Clicked an object from a previous step
                descText.innerText = 'This step has already been completed. ' + (CONFIG.steps[expectedStepIndex]?.objectHint || '');
            } else {
                // Clicked an object from a future step
                descText.innerText = 'Complete previous steps first. ' + (CONFIG.steps[expectedStepIndex]?.objectHint || '');
            }
        });

        // Add hover feedback (optional)
        if (CONFIG.enableHoverFeedback) {
            viewer.addEventListener('mousemove', updateHoverFeedback);
            viewer.addEventListener('touchmove', updateHoverFeedback);
        }

        // ============================================
        // PLAYBACK FUNCTIONS
        // ============================================

        function playNextStep() {
            currentStepIndex++;
            const stepData = CONFIG.steps[currentStepIndex];

            // Update UI
            titleText.innerText = stepData.title;
            descText.innerText = stepData.desc;
            isAnimating = true;

            // Play the keyframe range
            playKeyframeRange(stepData);
        }

        function resetExperience() {
            currentStepIndex = -1;
            titleText.innerText = CONFIG.resetTitle;
            descText.innerText = CONFIG.resetDesc;
            
            // Reset to first frame
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            isAnimating = false;
        }

        // ============================================
        // ERROR HANDLING
        // ============================================
        
        viewer.addEventListener('error', (event) => {
            console.error('Model loading error:', event.detail);
            titleText.innerText = 'Error';
            descText.innerText = 'Failed to load 3D model. Check console for details.';
        });

        viewer.addEventListener('load', () => {
            console.log('Model loaded successfully');
        });

        // ============================================
        // HELPER: Debug object names
        // ============================================

        // Uncomment to debug object names:
        // viewer.addEventListener('load', () => {
        //     const scene = viewer.getScene();
        //     console.log('=== All Objects in Model ===');
        //     scene.traverse((object) => {
        //         if (object.isMesh) {
        //             console.log(`Name: "${object.name}", Type: ${object.type}`);
        //         }
        //     });
        // });

    </script>
</body>
</html>
