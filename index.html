<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tap-to-Advance AR Experience</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    
    <style>
        /* --- CSS STYLING --- */
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Helvetica', 'Arial', sans-serif; 
            overflow: hidden; 
        }
        
        /* The AR Window */
        model-viewer {
            width: 100vw;
            height: 100vh;
            background-color: #f5f5f5; /* Fallback color */
            --poster-color: #f5f5f5;
        }

        /* The UI Overlay Container */
        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Let taps pass through to the 3D model */
            z-index: 100;
        }

        /* The Branding / Instruction Card */
        .card {
            display: inline-block;
            background: white;
            padding: 16px 24px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .card h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card p {
            margin: 4px 0 0 0;
            font-size: 14px;
            color: #555;
        }

        /* Hide UI while loading */
        model-viewer:not([loaded]) #ui-layer { 
            opacity: 0; 
        }

        /* Custom AR Button Styling */
        #ar-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 200;
            cursor: pointer;
            transition: background 0.2s;
        }

        #ar-button:hover {
            background: #0056CC;
        }
    </style>
</head>
<body>

    <model-viewer 
        id="ar-viewer"
        src="assets/Dalgona-OneTake_0001.glb"
        ar
        ar-modes="webxr scene-viewer quick-look"
        camera-controls
        disable-tap
        shadow-intensity="1.2"
        environment-image="assets/bryanston_park_sunrise_1k.hdr" 
        tone-mapping="commerce"
        animation-name="animation_0"
        autoplay="false">
        
        <button slot="ar-button" id="ar-button">
            View in your space
        </button>
    </model-viewer>

    <div id="ui-layer">
        <div class="card" id="info-card">
            <h2 id="step-title">Welcome</h2>
            <p id="step-desc">Tap the Nescaf√© sachet to start!</p>
        </div>
    </div>

    <script type="module">
        // ============================================
        // ON-SCREEN CONSOLE FOR MOBILE DEBUGGING
        // ============================================
        
        function createOnScreenConsole() {
            const consoleDiv = document.createElement('div');
            consoleDiv.id = 'mobile-console';
            consoleDiv.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 200px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.95);
                color: #0f0;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 8px;
                z-index: 10000;
                display: none;
                border-top: 2px solid #0f0;
                box-shadow: 0 -2px 10px rgba(0, 255, 0, 0.3);
            `;
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úï';
            closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: #f00;
                color: white;
                border: none;
                border-radius: 3px;
                width: 24px;
                height: 24px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                z-index: 10001;
            `;
            closeBtn.onclick = () => {
                consoleDiv.style.display = 'none';
            };
            consoleDiv.appendChild(closeBtn);
            
            // Add clear button
            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 35px;
                background: #333;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 8px;
                cursor: pointer;
                font-size: 10px;
                z-index: 10001;
            `;
            clearBtn.onclick = () => {
                const logs = consoleDiv.querySelectorAll('div:not(button)');
                logs.forEach(log => log.remove());
            };
            consoleDiv.appendChild(clearBtn);
            
            document.body.appendChild(consoleDiv);
            
            // Store original console methods
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;
            
            function addToScreen(type, ...args) {
                const consoleDiv = document.getElementById('mobile-console');
                if (!consoleDiv) return;
                
                const message = args.map(arg => {
                    if (arg === null) return 'null';
                    if (arg === undefined) return 'undefined';
                    if (typeof arg === 'object') {
                        try {
                            return JSON.stringify(arg, null, 2);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return String(arg);
                }).join(' ');
                
                const logEntry = document.createElement('div');
                logEntry.style.cssText = `
                    padding: 3px 0;
                    border-bottom: 1px solid #222;
                    word-wrap: break-word;
                    color: ${type === 'error' ? '#ff4444' : type === 'warn' ? '#ffaa00' : type === 'info' ? '#00aaff' : '#00ff00'};
                    white-space: pre-wrap;
                `;
                
                const timestamp = new Date().toLocaleTimeString();
                logEntry.textContent = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
                consoleDiv.appendChild(logEntry);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                
                // Auto-show console for errors and warnings
                if (type === 'error' || type === 'warn') {
                    consoleDiv.style.display = 'block';
                }
            }
            
            // Override console methods
            console.log = function(...args) {
                originalLog.apply(console, args);
                addToScreen('log', ...args);
            };
            
            console.error = function(...args) {
                originalError.apply(console, args);
                addToScreen('error', ...args);
            };
            
            console.warn = function(...args) {
                originalWarn.apply(console, args);
                addToScreen('warn', ...args);
            };
            
            console.info = function(...args) {
                if (originalInfo) originalInfo.apply(console, args);
                addToScreen('info', ...args);
            };
            
            // Toggle console with triple tap
            let tapCount = 0;
            let tapTimer = null;
            document.addEventListener('touchstart', (e) => {
                // Don't trigger on UI elements
                if (e.target.tagName === 'BUTTON' || e.target.closest('#ui-layer')) {
                    return;
                }
                
                tapCount++;
                clearTimeout(tapTimer);
                tapTimer = setTimeout(() => {
                    if (tapCount === 3) {
                        const consoleDiv = document.getElementById('mobile-console');
                        if (consoleDiv) {
                            consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                        }
                    }
                    tapCount = 0;
                }, 400);
            });
            
            // Also allow keyboard toggle (for desktop testing)
            document.addEventListener('keydown', (e) => {
                if (e.key === '`' && e.ctrlKey) {
                    e.preventDefault();
                    const consoleDiv = document.getElementById('mobile-console');
                    if (consoleDiv) {
                        consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                    }
                }
            });
            
            console.log('On-screen console initialized. Triple-tap to toggle, or press Ctrl+`');
        }
        
        // Initialize console immediately
        createOnScreenConsole();
        
        // ============================================
        // CONFIGURATION: Keyframe-based animation with object-specific taps
        // ============================================
        
        const CONFIG = {
            // Path to your 3D model (GLB format)
            modelPath: 'assets/Dalgona-OneTake_0001.glb',
            
            // Path to iOS USDZ format (optional, for better iOS support)
            // Note: USDZ file not present, iOS will use GLB
            iosModelPath: null,
            
            // Animation name (single track)
            animationName: 'animation_0',
            
            // Frame rate of your animation
            fps: 30,
            
            // Keyframe spans for each step
            steps: [
                { 
                    startFrame: 1,
                    endFrame: 80,
                    title: 'Step 1: The Mix', 
                    desc: 'Nescaf√© + Water into bowl',
                    objectHint: 'Tap the Nescaf√© sachet, pot, or handle'
                },
                { 
                    startFrame: 80,
                    endFrame: 140,
                    title: 'Step 2: Whip It', 
                    desc: 'Whisking into foam...',
                    objectHint: 'Tap the whisk'
                },
                { 
                    startFrame: 140,
                    endFrame: 200,
                    title: 'Step 3: The Base', 
                    desc: 'Milk into mug...',
                    objectHint: 'Tap the jug'
                },
                { 
                    startFrame: 200,
                    endFrame: 240,
                    title: 'Step 4: Transfer', 
                    desc: 'Bowl into mug...',
                    objectHint: 'Tap the mixing bowl'
                },
                { 
                    startFrame: 240,
                    endFrame: 300,
                    title: 'Step 5: Final Touch', 
                    desc: 'Add ice...',
                    objectHint: 'Tap the scoop or ice bowl',
                    loop: false
                }
            ],
            
            // Object names that trigger each step (will be matched flexibly against GLB node names)
            // Note: Matching is flexible - handles dots/underscores, spaces/underscores, case variations
            interactiveObjects: [
                ['NescafeBTM', 'NescafeTOP_(Copy)', 'NescafeTOP', 'teapot', 'pot', 'handle'],  // Step 1
                ['whisk'],                                                // Step 2
                ['jug'],                                                  // Step 3
                ['mixingbowl', 'mixing.bowl'],                            // Step 4
                ['scoop', 'icebowl', 'ice.bowl']                          // Step 5
            ],
            
            // Welcome message
            welcomeTitle: 'Welcome',
            welcomeDesc: 'Tap the Nescaf√© sachet to start!',
            
            // Continue prompt
            continuePrompt: 'Tap the correct object to continue ->',
            
            // Reset message
            resetTitle: 'Replay?',
            resetDesc: 'Tap to start again.',
            
            // Visual feedback for interactive objects
            enableHoverFeedback: true
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        
        const viewer = document.querySelector('#ar-viewer');
        const titleText = document.querySelector('#step-title');
        const descText = document.querySelector('#step-desc');
        const card = document.querySelector('#info-card');

        // Set model paths from config
        viewer.src = CONFIG.modelPath;
        // Only set iOS source if it exists (USDZ provides better iOS Quick Look support)
        if (CONFIG.iosModelPath) {
            viewer.setAttribute('ios-src', CONFIG.iosModelPath);
        } else {
            console.log('No USDZ file specified - iOS will use GLB (may have limitations)');
        }
        viewer.animationName = CONFIG.animationName;
        viewer.autoplay = false;
        viewer.loop = false;

        // Set welcome message
        titleText.innerText = CONFIG.welcomeTitle;
        descText.innerText = CONFIG.welcomeDesc;

        // ============================================
        // MODEL-VIEWER CLICK EVENT SETUP
        // ============================================
        
        // Map of node names to step indices (with flexible matching)
        let nodeToStepMap = new Map();
        let hierarchyNodes = []; // Store hierarchy nodes with meshes
        let THREE = null; // Will store Three.js reference
        let raycaster = null;
        let camera = null;
        
        // Initialize after model loads
        viewer.addEventListener('load', () => {
            // Set initial time to frame 1
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            
            // Wait a bit for canvas to be properly sized
            setTimeout(() => {
                // Access hierarchy and build mappings
                setupHitDetection();
            }, 100);
        });
        
        // Also listen for scene-graph-ready event
        viewer.addEventListener('scene-graph-ready', () => {
            console.log('Scene graph ready');
            // Wait a bit for canvas to be properly sized
            setTimeout(() => {
                setupHitDetection();
            }, 100);
        });
        
        // Also check when the viewer is resized (canvas might be sized then)
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log('Window resized, checking canvas size');
                const canvas = viewer.renderRoot?.querySelector('canvas');
                if (canvas) {
                    const rect = canvas.getBoundingClientRect();
                    console.log('Canvas size after resize:', { width: rect.width, height: rect.height });
                }
            }, 250);
        });
        
        function setupHitDetection() {
            console.log('Setting up hit detection...', {
                modelLoaded: viewer.loaded,
                hasTHREE: typeof THREE !== 'undefined'
            });
            
            // Wait for model to load
            if (!viewer.loaded) {
                console.log('Model not loaded yet, waiting...');
                viewer.addEventListener('load', () => {
                    console.log('Model loaded, retrying hit detection setup...');
                    setupHitDetection();
                }, { once: true });
                return;
            }
            
            // Import Three.js for raycasting
            if (!window.THREE) {
                console.log('Three.js not found, importing...');
                import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js').then((THREE_Module) => {
                    window.THREE = THREE_Module;
                    THREE = THREE_Module;
                    console.log('Three.js imported successfully');
                    initializeHitDetection();
                }).catch((err) => {
                    console.error('Failed to import Three.js:', err);
                });
            } else {
                THREE = window.THREE;
                console.log('Three.js already available');
                initializeHitDetection();
            }
        }
        
        function initializeHitDetection() {
            if (!THREE) {
                console.error('Three.js not available');
                return;
            }
            
            console.log('Initializing hit detection...');
            
            // Access hierarchy from viewer.model
            const symbols = Object.getOwnPropertySymbols(viewer.model);
            const hierarchySym = symbols.find(s => s.toString().includes('hierarchy'));
            
            if (!hierarchySym) {
                console.error('Could not find hierarchy Symbol');
                console.log('Available symbols:', symbols.map(s => s.toString()));
                return;
            }
            
            const hierarchy = viewer.model[hierarchySym];
            hierarchyNodes = hierarchy.filter(node => node.mesh); // Only nodes with meshes
            
            console.log('Found hierarchy nodes:', hierarchyNodes.length);
            console.log('Node names:', hierarchyNodes.map(n => n.name).filter(Boolean));
            
            // Build flexible node-to-step mapping
            buildFlexibleNodeMapping(hierarchyNodes);
            
            console.log('Node-to-step mapping:', Array.from(nodeToStepMap.entries()));
            
            // Initialize raycasting
            raycaster = new THREE.Raycaster();
            
            // Create camera for raycasting
            // Will be updated on each click to match model-viewer's camera
            camera = new THREE.PerspectiveCamera(
                75,
                viewer.clientWidth / viewer.clientHeight,
                0.1,
                1000
            );
            
            // Store reference to model-viewer's scene for easier access
            // Try to access through renderRoot
            if (viewer.renderRoot) {
                const canvas = viewer.renderRoot.querySelector('canvas');
                if (canvas && canvas.__THREE__) {
                    window.modelViewerScene = canvas.__THREE__.scene;
                    window.modelViewerCamera = canvas.__THREE__.camera;
                    console.log('Found model-viewer scene and camera');
                } else {
                    console.warn('Could not find model-viewer canvas or THREE context');
                }
            }
            
            console.log('‚úÖ Hit detection initialized successfully!');
        }
        
        function buildFlexibleNodeMapping(nodes) {
            // Normalize function to handle variations
            function normalizeName(name) {
                if (!name) return '';
                return name
                    .toLowerCase()
                    .replace(/[._\s-]/g, '') // Remove dots, underscores, spaces, hyphens
                    .trim();
            }
            
            // Build map with normalized names
            CONFIG.interactiveObjects.forEach((targetNames, stepIndex) => {
                const names = Array.isArray(targetNames) ? targetNames : [targetNames];
                names.forEach(configName => {
                    const normalized = normalizeName(configName);
                    nodeToStepMap.set(normalized, stepIndex);
                    
                    // Also check actual node names and create mappings
                    nodes.forEach(node => {
                        const nodeNormalized = normalizeName(node.name);
                        if (nodeNormalized === normalized || 
                            nodeNormalized.includes(normalized) || 
                            normalized.includes(nodeNormalized)) {
                            // Map both the config name and actual node name
                            nodeToStepMap.set(node.name, stepIndex);
                            nodeToStepMap.set(normalized, stepIndex);
                        }
                    });
                });
            });
            
        }
        
        // Function to find which node was hit using raycasting
        function findHitNode(clientX, clientY) {
            if (!raycaster) {
                console.error('Raycaster not initialized');
                return null;
            }
            if (!camera) {
                console.error('Camera not initialized');
                return null;
            }
            if (!hierarchyNodes || hierarchyNodes.length === 0) {
                console.error('No hierarchy nodes available');
                return null;
            }
            
            // IMPORTANT: Use viewer.getBoundingClientRect() directly as per documentation
            // This ensures coordinates match the visible rendering area
            // The canvas might be in shadow DOM with different positioning, so use viewer instead
            const rect = viewer.getBoundingClientRect();
            
            // Validate rect has valid dimensions
            if (!rect || rect.width === 0 || rect.height === 0) {
                console.error('Invalid rect dimensions - cannot raycast:', {
                    rect,
                    viewerSize: { width: viewer.clientWidth, height: viewer.clientHeight }
                });
                return null;
            }
            
            // Calculate normalized device coordinates (-1 to +1) directly
            // Following the exact formula from the documentation:
            // x = ((clientX - rect.left) / rect.width) * 2 - 1
            // y = -((clientY - rect.top) / rect.height) * 2 + 1
            const mouse = new THREE.Vector2();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            // Validate coordinates are within reasonable bounds (allow slight overflow for edge cases)
            const relativeX = clientX - rect.left;
            const relativeY = clientY - rect.top;
            if (relativeX < -10 || relativeX > rect.width + 10 || relativeY < -10 || relativeY > rect.height + 10) {
                console.warn('Click significantly outside bounds:', { 
                    relativeX, 
                    relativeY, 
                    width: rect.width, 
                    height: rect.height,
                    normalized: { x: mouse.x, y: mouse.y }
                });
            }
            
            // Validate normalized coordinates
            if (isNaN(mouse.x) || isNaN(mouse.y) || !isFinite(mouse.x) || !isFinite(mouse.y)) {
                console.error('Invalid normalized coordinates:', { 
                    mouse, 
                    relativeX: clientX - rect.left, 
                    relativeY: clientY - rect.top, 
                    rect 
                });
                return null;
            }
            
            // Debug logging
            console.log('Raycast from tap:', {
                tapCoords: { clientX, clientY },
                rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },
                relativeCoords: { x: clientX - rect.left, y: clientY - rect.top },
                normalizedCoords: { x: mouse.x, y: mouse.y },
                viewerSize: { width: viewer.clientWidth, height: viewer.clientHeight },
                formula: 'x = ((clientX - rect.left) / rect.width) * 2 - 1, y = -((clientY - rect.top) / rect.height) * 2 + 1'
            });
            
            // Get only interactive meshes (exclude ground, table, etc.)
            const interactiveMeshes = hierarchyNodes
                .map(node => node.mesh)
                .filter(mesh => {
                    if (!mesh || !mesh.isMesh) return false;
                    // Filter out non-interactive object names (case-insensitive)
                    const name = (mesh.name || '').toLowerCase();
                    const excludeNames = ['plane', 'ground', 'floor', 'table', 'base', 'surface'];
                    return !excludeNames.some(exclude => name === exclude || name.includes(exclude));
                });
            
            if (interactiveMeshes.length === 0) {
                console.warn('No interactive meshes found');
                return null;
            }
            
            // Try to sync camera with model-viewer's camera
            let threeCamera = null;
            if (viewer.renderRoot) {
                const canvas = viewer.renderRoot.querySelector('canvas');
                if (canvas && canvas.__THREE__) {
                    const renderer = canvas.__THREE__;
                    threeCamera = renderer.camera || renderer.scene?.children.find(child => child.isCamera);
                }
            }
            
            // Update camera to match model-viewer's camera
            try {
                if (threeCamera) {
                    // Copy camera properties
                    if (threeCamera.position) camera.position.copy(threeCamera.position);
                    if (threeCamera.quaternion) camera.quaternion.copy(threeCamera.quaternion);
                    camera.fov = threeCamera.fov || camera.fov;
                    camera.aspect = threeCamera.aspect || (rect.width / rect.height);
                    camera.near = threeCamera.near || camera.near;
                    camera.far = threeCamera.far || camera.far;
                    
                    // Update matrices - CRITICAL for accurate raycasting
                    camera.updateProjectionMatrix();
                    camera.updateMatrixWorld(true); // Force update
                    
                    // Also update world matrix if available
                    if (threeCamera.matrixWorld) {
                        camera.matrixWorld.copy(threeCamera.matrixWorld);
                    }
                } else {
                    // Fallback: update aspect ratio based on canvas/viewer size
                    camera.aspect = rect.width / rect.height;
                    camera.updateProjectionMatrix();
                    camera.updateMatrixWorld(true);
                }
            } catch (cameraError) {
                console.warn('Error syncing camera, using fallback:', cameraError);
                // Fallback: update aspect ratio based on canvas/viewer size
                camera.aspect = rect.width / rect.height;
                camera.updateProjectionMatrix();
                camera.updateMatrixWorld(true);
            }
            
            // Update raycaster with the tap coordinates
            try {
                raycaster.setFromCamera(mouse, camera);
            } catch (raycastError) {
                console.error('Error setting raycaster from camera:', raycastError);
                console.error('Raycast error details:', {
                    mouse: { x: mouse.x, y: mouse.y },
                    camera: {
                        position: camera.position,
                        fov: camera.fov,
                        aspect: camera.aspect
                    }
                });
                return null;
            }
            
            // Perform raycasting ONLY on interactive meshes
            let intersects;
            try {
                intersects = raycaster.intersectObjects(interactiveMeshes, true);
            } catch (intersectError) {
                console.error('Error during raycast intersection:', intersectError);
                console.error('Intersect error details:', {
                    interactiveMeshesCount: interactiveMeshes.length,
                    raycaster: {
                        ray: raycaster.ray,
                        near: raycaster.near,
                        far: raycaster.far
                    }
                });
                return null;
            }
            
            console.log('Raycast results:', {
                rayOrigin: raycaster.ray.origin,
                rayDirection: raycaster.ray.direction,
                intersections: intersects.length,
                hitObjects: intersects.map(i => i.object.name)
            });
            
            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                
                // Find which node this mesh belongs to
                const hitNode = hierarchyNodes.find(node => {
                    if (node.mesh === hitMesh) return true;
                    // Check parent chain
                    let parent = hitMesh.parent;
                    while (parent) {
                        if (node.mesh === parent) return true;
                        parent = parent.parent;
                    }
                    return false;
                });
                
                if (hitNode) {
                    console.log('‚úÖ Hit detected:', hitNode.name);
                    return hitNode.name;
                } else {
                    console.warn('Hit mesh found but no matching node:', hitMesh.name);
                }
            } else {
                console.log('‚ùå No intersections found');
            }
            
            return null;
        }


        // ============================================
        // KEYFRAME-BASED PLAYBACK FUNCTIONS
        // ============================================

        // Convert frame number to time in seconds
        function frameToTime(frame, fps = CONFIG.fps) {
            return frame / fps;
        }

        // Play a specific keyframe range
        function playKeyframeRange(stepData) {
            const startTime = frameToTime(stepData.startFrame);
            const endTime = frameToTime(stepData.endFrame);
            
            // Set the start time
            viewer.currentTime = startTime;
            
            // Play the animation
            viewer.play();
            viewer.loop = stepData.loop || false;
            
            // Monitor playback using requestAnimationFrame for smooth control
            function checkPlayback() {
                if (!isAnimating) return; // Stop if user advanced
                
                if (viewer.currentTime >= endTime) {
                    viewer.pause();
                    isAnimating = false;
                    
                    if (stepData.loop) {
                        // Restart this range
                        viewer.currentTime = startTime;
                        viewer.play();
                        requestAnimationFrame(checkPlayback);
                    } else {
                        // Finished
                        if (currentStepIndex < CONFIG.steps.length - 1) {
                            descText.innerText = CONFIG.continuePrompt;
                        }
                    }
                } else {
                    requestAnimationFrame(checkPlayback);
                }
            }
            
            requestAnimationFrame(checkPlayback);
        }

        // ============================================
        // OBJECT-SPECIFIC CLICK DETECTION USING MODEL-VIEWER'S CLICK EVENT
        // ============================================

        function getStepIndexForNode(nodeName) {
            if (!nodeName) return -1;
            
            // Try exact match first
            let stepIndex = nodeToStepMap.get(nodeName);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try flexible matching (normalize the name)
            function normalizeName(name) {
                return name.toLowerCase().replace(/[._\s-]/g, '').trim();
            }
            
            const normalized = normalizeName(nodeName);
            stepIndex = nodeToStepMap.get(normalized);
            if (stepIndex !== undefined) return stepIndex;
            
            // Try partial matching
            for (const [mappedName, mappedStep] of nodeToStepMap.entries()) {
                const mappedNormalized = normalizeName(mappedName);
                if (normalized === mappedNormalized || 
                    normalized.includes(mappedNormalized) || 
                    mappedNormalized.includes(normalized)) {
                    return mappedStep;
                }
            }
            
            return -1;
        }

        // ============================================
        // AR AVAILABILITY CHECK & DESKTOP HANDLING
        // ============================================
        
        // Detect mobile devices
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Check if WebXR is available (for desktop AR)
        async function checkWebXRSupport() {
            if (!navigator.xr) {
                return false;
            }
            
            try {
                // Check if immersive-ar session is supported
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                return supported;
            } catch (e) {
                console.log('WebXR check failed:', e);
                return false;
            }
        }
        
        // Handle AR button visibility and errors
        const arButton = document.querySelector('#ar-button');
        
        // Track current AR mode
        let currentARMode = null;
        let isInQuickLook = false;
        
        // Listen for AR status changes with detailed logging
        viewer.addEventListener('ar-status', (event) => {
            const status = event.detail.status;
            const mode = event.detail.mode;
            currentARMode = mode;
            
            console.log('AR status:', status);
            console.log('AR mode:', mode);
            console.log('AR status detail:', event.detail);
            
            if (status === 'failed') {
                console.error('=== AR INITIALIZATION FAILED ===');
                console.log('Failed AR mode:', mode);
                console.log('AR modes configured:', viewer.arModes);
                console.log('AR available:', viewer.arAvailable);
                console.log('AR supported:', viewer.arSupported);
                console.log('Model loaded:', viewer.loaded);
                console.log('Model source:', viewer.src);
                console.log('iOS source:', viewer.iosSrc);
                console.log('User agent:', navigator.userAgent);
                console.log('Is HTTPS:', location.protocol === 'https:');
                
                // Check for common issues
                if (!viewer.loaded) {
                    console.error('‚ùå Model not loaded - AR cannot initialize');
                }
                // Only warn if explicitly false, not if undefined (might still be checking)
                if (viewer.arSupported === false) {
                    console.error('‚ùå AR not supported on this device/browser');
                } else if (viewer.arSupported === undefined) {
                    console.log('‚ÑπÔ∏è AR support status still being determined...');
                }
                if (viewer.arModes && viewer.arModes.length === 0) {
                    console.error('‚ùå No AR modes available');
                }
                if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                    console.error('‚ùå AR requires HTTPS (except localhost)');
                }
                if (mode === 'quick-look' && !viewer.iosSrc) {
                    console.warn('‚ö†Ô∏è Quick Look requires USDZ file for iOS');
                }
                if (mode === 'scene-viewer') {
                    console.log('Scene Viewer failed - checking Android compatibility');
                    console.log('Android version check:', /Android/.test(navigator.userAgent));
                }
                console.log('=== END AR FAILURE DIAGNOSTICS ===');
            } else if (status === 'not-presenting') {
                console.log('AR available but not active');
                isInQuickLook = false;
                // Make sure button is visible if AR is available
                if (mode === 'webxr' && !isMobileDevice()) {
                    console.log('WebXR mode detected - ensuring AR button is visible');
                    arButton.style.display = '';
                }
            } else if (status === 'presenting') {
                console.log('AR is active!');
                console.log('AR mode:', mode);
                
                if (mode === 'quick-look') {
                    isInQuickLook = true;
                    console.warn('‚ö†Ô∏è QUICK LOOK MODE ACTIVE');
                    console.warn('‚ö†Ô∏è Quick Look does NOT support JavaScript interactions!');
                    console.warn('‚ö†Ô∏è Tap-to-advance animations will NOT work in Quick Look.');
                    console.warn('‚ö†Ô∏è Quick Look is a native iOS app - your JavaScript code does not run there.');
                    console.warn('üí° Tip: Use WebXR mode instead for interactive AR (if available).');
                    
                    // Show user-friendly message
                    setTimeout(() => {
                        descText.innerText = 'Quick Look mode: Interactions disabled. Use WebXR for interactive AR.';
                        titleText.innerText = 'Quick Look Active';
                    }, 500);
                } else if (mode === 'webxr') {
                    isInQuickLook = false;
                    console.log('‚úÖ WebXR AR session started successfully!');
                    console.log('‚úÖ JavaScript interactions ARE supported in WebXR mode.');
                } else if (mode === 'scene-viewer') {
                    isInQuickLook = false;
                    console.log('‚úÖ Scene Viewer AR active (Android)');
                    console.warn('‚ö†Ô∏è Scene Viewer may have limited JavaScript support.');
                }
            }
        });
        
        // Catch AR launch errors (like the Intent URL error on desktop)
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('intent://')) {
                console.warn('AR Intent URL not supported on this device');
                if (!isMobileDevice()) {
                    console.info('Scene Viewer (Android) requires a mobile device.');
                    console.info('WebXR AR may still be available - try clicking the AR button.');
                }
            }
        });
        
        // Check AR availability after model loads
        viewer.addEventListener('load', async () => {
            console.log('Model loaded, checking AR availability...');
            console.log('AR modes configured:', viewer.arModes);
            console.log('Model loaded:', viewer.loaded);
            console.log('Model source:', viewer.src);
            console.log('iOS source:', viewer.iosSrc);
            
            const isMobile = isMobileDevice();
            
            // Function to check AR availability more reliably
            const checkARAvailability = async () => {
                // Check properties (they might be undefined initially)
                const arAvailable = viewer.arAvailable;
                const arSupported = viewer.arSupported;
                
                console.log('AR availability check:', {
                    arAvailable: arAvailable,
                    arSupported: arSupported,
                    arModes: viewer.arModes,
                    isMobile: isMobile,
                    userAgent: navigator.userAgent
                });
                
                // On iOS, Quick Look might be available even if arAvailable is undefined
                // Check if AR button is actually functional by checking if it's in the DOM
                const arButtonSlot = viewer.querySelector('[slot="ar-button"]');
                const hasARButton = !!arButtonSlot;
                
                // Check WebXR support for desktop
                let webXRSupported = false;
                if (!isMobile) {
                    webXRSupported = await checkWebXRSupport();
                    console.log('WebXR support check:', webXRSupported);
                    console.log('Protocol:', location.protocol);
                    console.log('Hostname:', location.hostname);
                    
                    if (webXRSupported) {
                        console.log('‚úÖ WebXR is available! Desktop AR should work.');
                        console.log('Requirements:');
                        console.log('- HTTPS or localhost:', location.protocol === 'https:' || location.hostname === 'localhost');
                        console.log('- Chrome/Edge browser recommended');
                        console.log('- Camera permissions will be requested');
                    } else {
                        console.log('‚ö†Ô∏è WebXR not available on desktop');
                        console.log('To enable WebXR:');
                        console.log('1. Use Chrome or Edge browser');
                        console.log('2. Ensure HTTPS (or localhost)');
                        console.log('3. Check chrome://flags/#webxr-incubations (if needed)');
                    }
                }
                
                // Only hide button if AR is definitely not available AND WebXR is not supported (on desktop)
                if (arAvailable === false && !isMobile && !webXRSupported) {
                    console.log('Hiding AR button - AR explicitly not available');
                    arButton.style.display = 'none';
                } else {
                    // Keep button visible - either AR is available, or we're on mobile (where Quick Look might work)
                    console.log('Keeping AR button visible');
                    arButton.style.display = '';
                }
                
                // Log AR capabilities (only warn if explicitly false, not if undefined)
                if (isMobile) {
                    console.log('Mobile device detected');
                    console.log('AR available:', arAvailable !== undefined ? arAvailable : 'checking...');
                    console.log('AR supported:', arSupported !== undefined ? arSupported : 'checking...');
                    
                    // On iOS, Quick Look might work even if arAvailable is undefined
                    if (arAvailable === false) {
                        console.warn('‚ö†Ô∏è AR explicitly not available on this mobile device');
                        console.log('Possible reasons:');
                        console.log('1. Browser does not support AR');
                        console.log('2. Model file too large');
                        console.log('3. Missing USDZ file (for iOS)');
                        console.log('4. Camera permissions not granted');
                        console.log('5. Device does not support AR');
                    } else if (arAvailable === undefined) {
                        console.log('‚ÑπÔ∏è AR availability still being determined...');
                        console.log('On iOS, Quick Look may still work even if this is undefined.');
                        console.log('Try clicking the AR button to test.');
                    } else {
                        console.log('‚úÖ AR appears to be available!');
                    }
                } else {
                    console.log('Desktop device detected');
                    console.log('AR available (model-viewer):', arAvailable !== undefined ? arAvailable : 'checking...');
                    console.log('WebXR available:', webXRSupported);
                    if (arAvailable === true || webXRSupported) {
                        console.log('‚úÖ AR should work on this desktop browser');
                    }
                }
            };
            
            // Check immediately
            await checkARAvailability();
            
            // Also check after a delay (AR capabilities might be determined asynchronously)
            setTimeout(async () => {
                console.log('Re-checking AR availability after delay...');
                await checkARAvailability();
            }, 2000);
            
            // Also check when AR status changes
            viewer.addEventListener('ar-status', async (event) => {
                if (event.detail.status === 'not-presenting') {
                    // AR is available but not active - this confirms AR works
                    console.log('‚úÖ AR confirmed available (status: not-presenting)');
                    arButton.style.display = '';
                }
            }, { once: true });
        });

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let currentStepIndex = -1; // Starts before the first step
        let isAnimating = false;

        // ============================================
        // EVENT HANDLERS
        // ============================================

        // ============================================
        // DEBUG: Log non-click events (click events handled separately)
        // ============================================
        const eventsToLog = ['ar-status', 'load', 'model-load', 'error', 'scene-graph-ready'];
        eventsToLog.forEach(eventType => {
            viewer.addEventListener(eventType, (e) => {
                console.log(`[${eventType}] event fired`);
                if (e.detail && typeof e.detail === 'object') {
                    console.log(`[${eventType}] event.detail:`, e.detail);
                }
            });
        });

        // OBJECT-SPECIFIC CLICK HANDLER USING RAYCASTING
        viewer.addEventListener('click', (event) => {
            console.log('Click event fired!', {
                target: event.target,
                type: event.type,
                isInQuickLook: isInQuickLook,
                currentARMode: currentARMode,
                hasRaycaster: !!raycaster,
                hierarchyNodesCount: hierarchyNodes.length
            });
            
            // Warn if in Quick Look mode
            if (isInQuickLook) {
                console.warn('‚ö†Ô∏è Click detected but Quick Look does not support JavaScript interactions');
                return;
            }
            
            // Ignore if animating (unless it's a looping step)
            if (isAnimating && !CONFIG.steps[currentStepIndex]?.loop) {
                console.log('Ignoring click - animation in progress');
                return;
            }
            
            // Ignore AR button clicks
            if (event.target && (event.target.id === 'ar-button' || event.target.closest('#ar-button'))) {
                console.log('Ignoring click - AR button');
                return;
            }
            
            // Get coordinates - handle both mouse and touch events
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                // Touch event
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                // Touch event (changedTouches for touchend)
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                // Mouse event
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            console.log('Click coordinates:', { clientX, clientY });
            
            // Check if raycasting is ready
            if (!raycaster || !hierarchyNodes.length) {
                console.warn('‚ö†Ô∏è Raycasting not ready:', {
                    hasRaycaster: !!raycaster,
                    hierarchyNodesCount: hierarchyNodes.length
                });
                descText.innerText = 'Loading... Please wait for model to initialize.';
                return;
            }
            
            // Use raycasting to find hit node
            let nodeName = null;
            try {
                nodeName = findHitNode(clientX, clientY);
            } catch (error) {
                console.error('Error in findHitNode:', error);
                console.error('Error details:', {
                    message: error?.message,
                    stack: error?.stack,
                    name: error?.name,
                    error: String(error)
                });
                return null;
            }
            
            // Log the node name for debugging (preserve the name)
            if (nodeName) {
                console.log('‚úÖ Hit node:', nodeName);
            } else {
                console.log('‚ùå No node hit at coordinates:', { clientX, clientY });
            }
            
            if (!nodeName) {
                // Clicked on empty space - show feedback
                if (currentStepIndex >= 0 && currentStepIndex < CONFIG.steps.length) {
                    const stepData = CONFIG.steps[currentStepIndex];
                    descText.innerText = stepData.objectHint || CONFIG.continuePrompt;
                } else {
                    descText.innerText = 'Tap an object to start!';
                }
                return;
            }
            
            // Find which step this node belongs to
            const objectStepIndex = getStepIndexForNode(nodeName);
            console.log('Node maps to step:', objectStepIndex);
            
            if (objectStepIndex === -1) {
                // Clicked node is not interactive
                console.log('Node is not in interactive objects list:', nodeName);
                if (currentStepIndex >= 0 && currentStepIndex < CONFIG.steps.length) {
                    const stepData = CONFIG.steps[currentStepIndex];
                    descText.innerText = stepData.objectHint || CONFIG.continuePrompt;
                }
                return;
            }
            
            // Check if this is the correct step to advance
            const expectedStepIndex = currentStepIndex + 1;
            
            if (objectStepIndex === expectedStepIndex) {
                // Correct object clicked - advance!
                console.log('‚úÖ Correct object clicked! Advancing to step', expectedStepIndex);
                playNextStep();
            } else if (objectStepIndex < expectedStepIndex) {
                // Clicked an object from a previous step
                console.log('‚ö†Ô∏è Clicked previous step object');
                descText.innerText = 'This step has already been completed. ' + (CONFIG.steps[expectedStepIndex]?.objectHint || '');
            } else {
                // Clicked an object from a future step
                console.log('‚ö†Ô∏è Clicked future step object');
                descText.innerText = 'Complete previous steps first. ' + (CONFIG.steps[expectedStepIndex]?.objectHint || '');
            }
        });
        
        // Also listen for touchstart/touchend to catch mobile taps
        viewer.addEventListener('touchstart', (event) => {
            console.log('Touchstart event fired');
            // Let the click handler process it
        });
        
        viewer.addEventListener('touchend', (event) => {
            console.log('Touchend event fired');
            // Let the click handler process it
        });


        // ============================================
        // PLAYBACK FUNCTIONS
        // ============================================

        function playNextStep() {
            currentStepIndex++;
            const stepData = CONFIG.steps[currentStepIndex];

            // Update UI
            titleText.innerText = stepData.title;
            descText.innerText = stepData.desc;
            isAnimating = true;

            // Play the keyframe range
            playKeyframeRange(stepData);
        }

        function resetExperience() {
            currentStepIndex = -1;
            titleText.innerText = CONFIG.resetTitle;
            descText.innerText = CONFIG.resetDesc;
            
            // Reset to first frame
            viewer.currentTime = frameToTime(1);
            viewer.pause();
            isAnimating = false;
        }

        // ============================================
        // ERROR HANDLING
        // ============================================
        
        viewer.addEventListener('error', (event) => {
            console.error('Model loading error:', event.detail);
            titleText.innerText = 'Error';
            descText.innerText = 'Failed to load 3D model. Check console for details.';
        });

        viewer.addEventListener('load', () => {
            console.log('Model loaded successfully');
            console.log('Click handler ready:', {
                hasRaycaster: !!raycaster,
                hierarchyNodesCount: hierarchyNodes.length,
                currentStepIndex: currentStepIndex,
                totalSteps: CONFIG.steps.length
            });
            
            // Test click detection setup
            if (!raycaster || !hierarchyNodes.length) {
                console.warn('‚ö†Ô∏è Click detection not fully initialized. Retrying...');
                setTimeout(() => {
                    setupHitDetection();
                }, 500);
            } else {
                console.log('‚úÖ Click detection ready! Try tapping objects.');
            }
        });

        // ============================================
        // HELPER: Debug object names
        // ============================================

        // Uncomment to debug object names:
        // viewer.addEventListener('load', () => {
        //     const scene = viewer.getScene();
        //     console.log('=== All Objects in Model ===');
        //     scene.traverse((object) => {
        //         if (object.isMesh) {
        //             console.log(`Name: "${object.name}", Type: ${object.type}`);
        //         }
        //     });
        // });

    </script>
</body>
</html>
